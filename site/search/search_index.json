{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"CRDDM","text":""},{"location":"#overview","title":"Overview","text":"<p>CRDDM is a Python package for modeling continuous-response decision tasks using Continuous-Response Diffusion Decision Models (CRDDM).</p> <p>The package provides fast and numerically stable likelihood evaluation for continuous-response diffusion models based on the integral equation method proposed by Hadian Rasanan et al. (2025). </p> <p>CRDDM is designed for researchers in cognitive science, mathematical psychology, and neuroscience who study decision-making with continuous-response spaces. </p>"},{"location":"#features","title":"Features","text":"<p>1. Support for diverse continuous response scales:</p> <p>CRDDM supports a wide range of continuous-response scales commonly used in experimental research, including:</p> <ul> <li>Bounded one-dimensional scales (e.g., arcs or sliders),</li> <li>Circular scales (e.g., color wheels),</li> <li>Two-dimensional scales (e.g., 2D planes).</li> </ul> <p>Examples of continuous-response decision tasks are illustrated below:</p> <p></p> <p>2. Time-dependent decision thresholds:</p> <p>CRDDM supports diffusion models with time-dependent decision thresholds and enables likelihood estimation for models with arbitrary threshold dynamics. Specifically, the package includes:</p> <ul> <li>Fixed threshold,</li> <li>Linear collapsing threshold,</li> <li>Exponential collapsing threshold,</li> <li>Hyperbolic collapsing threshold,</li> <li>User-defined threshold functions.</li> </ul> <p>This flexibility allows researchers to model urgency signals and dynamic decision boundaries in a principled way.</p>"},{"location":"#diffusion-models-of-continuous-response-taks","title":"Diffusion models of continuous-response taks","text":"<p>CRDDM includes four classes of multi-dimensional diffusion models, tailored to different response geometries:</p> <ul> <li>Circular Diffusion Models for experiments with circular response scales,</li> <li>(Hyper-)Spherical Diffusion Models for experiments with circular response scales,</li> <li>Projected Spherical Diffusion Models for experiments with one-dimensional bounded scales,</li> <li>Projected Hyper-spherical Diffusion Models for experiments with two-dimensional bounded scales.</li> </ul> <p></p>"},{"location":"#credits","title":"Credits","text":"<p>This package was developed by me, Amir Hosein Hadian Rasanan, with getting support from Dr. Nathan J Evans and Prof. Dr. J\u00f6rg Rieskamp. </p> <p>When using this package or part of the code for your own research, I ask you to cite us:</p> <p>Hadian Rasanan, A. H., Evans, N. J., and Rieskamp, J. (in prepration). Modeling Continuous-response Decisions with Multi-dimensional Diffusion Processes: A Tutorial</p> <p>Also don't forget to cite the original paper for each model. </p> <ul> <li>Circular Diffusion Model: Smith, P. L. (2016). Diffusion theory of decision making in continuous report. Psychological Review, 123(4), 425\u2013451. https://doi.org/10.1037/rev0000023</li> <li>Hyper-spherical Diffusion Model: Smith, P. L., &amp; Corbett, E. A. (2019). Speeded multielement decision-making as diffusion in a hypersphere: Theory and application to double-target detection. Psychonomic Bulletin &amp; Review, 26(1), 127-162. https://doi.org/10.3758/s13423-018-1491-0</li> <li>Projected Spherical Diffusion Model: Hadian Rasanan, A. H., Olschewski, S., &amp; Rieskamp, J. (in prepration) The Projected Spherical Diffusion Model: A Theory of Evidence Accumulation for Continuous Estimation Tasks</li> <li>Multi-dimensional Diffusion Models with Collapsing Decision Threshold: Hadian Rasanan, A. H., Evans, N. J., Amani Rad, J., &amp; Rieskamp, J. (2025). Parameter estimation of hyper-spherical diffusion models with a time-dependent threshold: An integral equation method. Behavior Research Methods, 57(10), 283. https://doi.org/10.3758/s13428-025-02810-3</li> </ul>"},{"location":"#support","title":"Support","text":"<p>If you have questions, encounter issues, or would like to contribute, please contact: amir.h.hadian@gmail.com</p>"},{"location":"api/","title":"API Reference","text":"<p>This reference is generated automatically from the package docstrings via mkdocstrings.</p>"},{"location":"api/#top-level-package","title":"Top-level package","text":""},{"location":"api/#CRDDM.CircularDiffusionModel","title":"<code>CircularDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Circular Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/Circular.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Circular Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.CircularDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.01)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angle</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>array - like</code> <p>Response times</p> required <code>theta</code> <code>array - like</code> <p>Choice angles in radians</p> required <code>drift_vec</code> <code>(array - like, shape(2) or (n_samples, 2))</code> <p>The drift vector [drift_x, drift_y]</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The initial decision threshold</p> required <code>decay</code> <code>float</code> <p>The decay rate of the threshold (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>The time step for numerical estimation of first-passage time densities (default is 0.01)</p> <code>0.01</code> <p>Returns:</p> Type Description <code>array - like</code> <p>The joint log-probability density evaluated at (rt, theta) with same shape as rt and theta</p> Source code in <code>CRDDM/Models/Circular.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.01):\n    '''\n    Compute the joint log-probability density function of response time and choice angle\n\n    Parameters\n    ----------\n    rt : array-like\n        Response times\n    theta : array-like\n        Choice angles in radians\n    drift_vec : array-like, shape (2,) or (n_samples, 2)\n        The drift vector [drift_x, drift_y]\n    ndt : float\n        The non-decision time\n    threshold : float\n        The initial decision threshold\n    decay : float\n        The decay rate of the threshold (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        The time step for numerical estimation of first-passage time densities (default is 0.01)\n\n    Returns\n    -------\n    array-like\n        The joint log-probability density evaluated at (rt, theta) with same shape as rt and theta\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 2))\n\n    if drift_vec.shape[1] != 2 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (2,) or (n_samples, 2)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = cdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * cdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)   \n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = cdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * cdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)   \n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 2, 0.000001, dt=dt, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 2, 0.000001, dt=dt, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 2, 0.000001, dt=dt, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 2, 0.000001, dt=dt, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        mu_dot_x0 = drift_vec[:, 0] * np.cos(theta)\n        mu_dot_x1 = drift_vec[:, 1] * np.sin(theta)\n\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = a * (mu_dot_x0 + mu_dot_x1) / sigma**2\n            term2 = 0.5 * (drift_vec[:, 0]**2 + drift_vec[:, 1]**2) * tt\n            log_density = term1 - term2 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            norm2_drift = drift_vec[:, 0]**2 + drift_vec[:, 1]**2\n            mu_dot_x = (mu_dot_x0 + mu_dot_x1) / sigma**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        integrand = np.exp(- 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * np.exp(threshold * mu_dot_x[i]) * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        integrand = np.exp((threshold - decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        integrand = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        integrand = np.exp(threshold/(1  + decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        integrand = np.exp(threshold_function(tt[i] - eps) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    else:\n        # With drift variability\n        if s_t == 0:\n            # No non-decision time variability     \n            s_v2 = s_v**2\n            x0 =  a * np.cos(theta)\n            x1 =  a * np.sin(theta)\n            fixed = 1/(np.sqrt(s_v2 * tt + 1))\n            exponent0 = -0.5*drift_vec[:, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[:, 0])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent1 = -0.5*drift_vec[:, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[:, 1])**2 / (s_v2 * (s_v2 * tt + 1))\n\n            log_density = 2*np.log(fixed) + exponent0 + exponent1 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        x0 =  threshold * np.cos(theta[i])\n                        x1 =  threshold * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'linear':\n                        x0 =  (threshold - decay * (tt[i]-eps)) * np.cos(theta[i])\n                        x1 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'exponential':\n                        x0 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.cos(theta[i])\n                        x1 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        x0 =  (threshold / (1 + decay * (tt[i]-eps))) * np.cos(theta[i])\n                        x1 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'custom':\n                        x0 =  threshold_function(tt[i]-eps) * np.cos(theta[i])\n                        x1 =  threshold_function(tt[i]-eps) * np.sin(theta[i])\n                    fixed = 1/(np.sqrt(s_v2 * (tt[i]-eps) + 1))\n                    exponent0 = -0.5*drift_vec[i, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[i, 0])**2 / (s_v2 * (s_v2 * (tt[i]-eps) + 1))\n                    exponent1 = -0.5*drift_vec[i, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[i, 1])**2 / (s_v2 * (s_v2 * (tt[i]-eps) + 1))\n\n                    integrand = fixed**2 * np.exp(exponent0 + exponent1) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                    density = 1/(2*np.pi) * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    log_density[rt - ndt - s_t &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.CircularDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate data from the Circular Diffusion Model with collapsing boundaries</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>(array - like, shape(2))</code> <p>The drift vector [drift_x, drift_y]</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The initial decision threshold (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>The decay rate of the threshold (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>The time step for simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>The number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/Circular.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate data from the Circular Diffusion Model with collapsing boundaries\n\n    Parameters\n    ----------\n    drift_vec : array-like, shape (2,)\n        The drift vector [drift_x, drift_y]\n    ndt : float\n        The non-decision time\n    threshold : float\n        The initial decision threshold (default is 1)\n    decay : float\n        The decay rate of the threshold (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        The time step for simulation (default is 0.001)\n    n_sample : int, optional\n        The number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''\n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample,))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 2))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_CDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n], \n                                                  threshold_dynamic=self.threshold_dynamic,\n                                                  decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_custom_threshold_CDM_trial(threshold_function,\n                                                                   drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                   s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response'])\n</code></pre>"},{"location":"api/#CRDDM.HyperSphericalDiffusionModel","title":"<code>HyperSphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Hyper-Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Hyper-Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.HyperSphericalDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angles</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>(array - like, shape(n_samples))</code> <p>The response times</p> required <code>theta</code> <code>(array - like, shape(n_samples, 3))</code> <p>The choice angles in spherical coordinates (theta1, theta2, theta3)</p> required <code>drift_vec</code> <code>(array - like, shape(4) or (n_samples, 4))</code> <p>The drift rates in each dimension</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> required <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>log_density</code> <code>(array - like, shape(n_samples))</code> <p>The joint log-probability density of response time and choice angles</p> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1):\n    '''\n    Compute the joint log-probability density function of response time and choice angles\n\n    Parameters\n    ----------\n    rt : array-like, shape (n_samples,)\n        The response times\n    theta : array-like, shape (n_samples, 3)\n        The choice angles in spherical coordinates (theta1, theta2, theta3)\n    drift_vec : array-like, shape (4,) or (n_samples, 4)\n        The drift rates in each dimension\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n\n    Returns\n    -------\n    log_density : array-like, shape (n_samples,)\n        The joint log-probability density of response time and choice angles\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 4))\n\n    if drift_vec.shape[1] != 4 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (4,) or (n_samples, 4)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = hsdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * hsdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)\n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1) \n            fpt_lt = hsdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * hsdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)\n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 4, 0.000001, dt=0.02, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 4, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 4, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 4, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        mu_dot_x0 = drift_vec[:, 0]*np.cos(theta[:, 0])\n        mu_dot_x1 = drift_vec[:, 1]*np.sin(theta[:, 0])*np.cos(theta[:, 1]) \n        mu_dot_x2 = drift_vec[:, 2]*np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.cos(theta[:, 2])\n        mu_dot_x3 = drift_vec[:, 3]*np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.sin(theta[:, 2])\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = a * (mu_dot_x0 + mu_dot_x1 + mu_dot_x2 + mu_dot_x3) / sigma**2\n            term2 = 0.5 * (drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2 + drift_vec[:, 3]**2) * tt\n            log_density = term1 - term2 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            norm2_drift = drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2 + drift_vec[:, 3]**2\n            mu_dot_x = (mu_dot_x0 + mu_dot_x1 + mu_dot_x2 + mu_dot_x3) / sigma**2\n\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        integrand = np.exp(- 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * np.exp(threshold * mu_dot_x[i]) * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        integrand = np.exp((threshold - decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        integrand = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        integrand = np.exp(threshold/(1  + decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        integrand = np.exp(threshold_function(tt[i] - eps) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n    else:\n        # With drift variability\n        if s_t == 0:\n            s_v2 = s_v**2\n            x0 =  a * np.cos(theta[:, 0])\n            x1 =  a * np.sin(theta[:, 0])*np.cos(theta[:, 1])\n            x2 =  a * np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.cos(theta[:, 2])\n            x3 =  a * np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.sin(theta[:, 2])\n            fixed = 1/(np.sqrt(s_v2 * tt + 1))\n            exponent0 = -0.5*drift_vec[:, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[:, 0])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent1 = -0.5*drift_vec[:, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[:, 1])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent2 = -0.5*drift_vec[:, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[:, 2])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent3 = -0.5*drift_vec[:, 3]**2/s_v2 + 0.5*(x3 * s_v2 + drift_vec[:, 3])**2 / (s_v2 * (s_v2 * tt + 1))\n\n            # the joint density of choice and RT for the full process\n            log_density = 4*np.log(fixed) + exponent0 + exponent1 + exponent2 + exponent3 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        x0 =  threshold * np.cos(theta[i, 0])\n                        x1 =  threshold * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  threshold * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  threshold * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'linear':\n                        x0 =  (threshold - decay * (tt[i]-eps)) * np.cos(theta[i, 0])\n                        x1 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'exponential':\n                        x0 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        x0 =  (threshold / (1 + decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'custom':\n                        x0 =  threshold_function(tt[i]-eps) * np.cos(theta[i, 0])\n                        x1 =  threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    fixed = 1/(np.sqrt(s_v2 * (tt[i] - eps) + 1))\n                    exponent0 = -0.5*drift_vec[i, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[i, 0])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent1 = -0.5*drift_vec[i, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[i, 1])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent2 = -0.5*drift_vec[i, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[i, 2])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent3 = -0.5*drift_vec[i, 3]**2/s_v2 + 0.5*(x3 * s_v2 + drift_vec[i, 3])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n\n                    integrand = fixed**4 * np.exp(exponent0 + exponent1 + exponent2 + exponent3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                    density = 1/(2*np.pi) * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    log_density[rt - ndt &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.HyperSphericalDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate data from the Hyper-Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>(array - like, shape(4))</code> <p>The drift rates in each dimension</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>Time step for the simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>Number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate data from the Hyper-Spherical Diffusion Model\n\n    Parameters\n    ----------\n    drift_vec : array-like, shape (4,)\n        The drift rates in each dimension\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        Time step for the simulation (default is 0.001)\n    n_sample : int, optional\n        Number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''\n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample, 3))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 4))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_HSDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n],\n                                                      threshold_dynamic=self.threshold_dynamic, \n                                                      decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_custom_threshold_HSDM_trial(threshold_function,\n                                                                       drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                       s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response1', 'response2', 'response3'])\n</code></pre>"},{"location":"api/#CRDDM.ProjectedHyperSphericalDiffusionModel","title":"<code>ProjectedHyperSphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Projected Hyper-Spherical Diffusion Model</p> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    self.name = 'Projected Hyper-Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.ProjectedSphericalDiffusionModel","title":"<code>ProjectedSphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Projected Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Projected Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.ProjectedSphericalDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angle</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>(array - like, shape(n_samples))</code> <p>The response times</p> required <code>theta</code> <code>(array - like, shape(n_samples))</code> <p>The choice angles in radians</p> required <code>drift_vec</code> <code>(array - like, shape(2) or (n_samples, 2))</code> <p>The drift vector [drift_x, drift_y]</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> required <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>log_density</code> <code>(array - like, shape(n_samples))</code> <p>The joint log-probability density of response time and choice angle</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1):\n    '''\n    Compute the joint log-probability density function of response time and choice angle\n\n    Parameters\n    ----------\n    rt : array-like, shape (n_samples,)\n        The response times\n    theta : array-like, shape (n_samples,)\n        The choice angles in radians\n    drift_vec : array-like, shape (2,) or (n_samples, 2)\n        The drift vector [drift_x, drift_y]\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n\n    Returns\n    -------\n    log_density : array-like, shape (n_samples,)\n        The joint log-probability density of response time and choice angle\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 2))\n\n    if drift_vec.shape[1] != 2 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (2,) or (n_samples, 2)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)   \n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)   \n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 3, 0.000001, dt=0.02, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    norm_mu = np.sqrt(drift_vec[:, 0]**2 + drift_vec[:, 1]**2)\n    theta_mu = np.arctan2(drift_vec[:, 1], drift_vec[:, 0])\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = np.exp(a * norm_mu * np.cos(theta_mu) * np.cos(theta))\n            term2 = iv(0, a * norm_mu * np.sin(theta_mu) * np.sin(theta))\n            term3 = -0.5 * norm_mu**2 * tt\n            log_density = np.log(2*np.pi) + np.log(term1) + np.log(term2) + term3 + np.log(fpt_z)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        term1 = np.exp(threshold * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * term1 * term2 * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        term1 = np.exp((threshold - decay * (tt[i] - eps)) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, (threshold - decay * (tt[i] - eps)) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        term1 = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold*np.exp(-decay * (tt[i] - eps)) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        term1 = np.exp(threshold/(1  + decay * (tt[i] - eps)) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold/(1  + decay * (tt[i] - eps)) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        term1 = np.exp(threshold_function(tt[i] - eps) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold_function(tt[i] - eps) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n    else:\n        # With drift variability\n        if s_t == 0:\n            # No non-decision time variability\n            s_v2 = s_v**2\n            c1 = a * np.sin(theta) * s_v2\n            c2 = 2*s_v2 * (s_v2 * tt + 1)\n            term1 = 2*np.pi * iv(0, 2*c1 * drift_vec[:, 1]/c2)\n            term2 = (1/(np.sqrt(s_v2 * tt + 1)))**3\n            p1 = (c1**2 + drift_vec[:, 1]**2)/c2\n            p2 = (a * np.cos(theta) * s_v2 + drift_vec[:, 0])**2 / c2\n            p3 = (norm_mu**2)/(2*s_v2)\n            term3 = np.exp(p1 + p2 - p3)\n\n            log_density = np.log(term1) + np.log(term2) + np.log(term3) + np.log(fpt_z)\n        else:\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    c2 = 2*s_v2 * (s_v2 * (tt[i] - eps) + 1)\n                    if self.threshold_dynamic == 'fixed':\n                        c1 = threshold * np.sin(theta[i]) * s_v2\n                        p2 = (threshold * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'linear':\n                        c1 = (threshold - decay*(tt[i]-eps)) * np.sin(theta[i]) * s_v2\n                        p2 = ((threshold - decay*(tt[i]-eps)) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'exponential':\n                        c1 = (threshold * np.exp(-decay*(tt[i]-eps))) * np.sin(theta[i]) * s_v2\n                        p2 = ((threshold * np.exp(-decay*(tt[i]-eps))) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        c1 = (threshold / (1 + decay*(tt[i]-eps))) * np.sin(theta[i]) * s_v2\n                        p2 = ((threshold / (1 + decay*(tt[i]-eps))) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'custom':\n                        c1 = threshold_function(tt[i]-eps) * np.sin(theta[i]) * s_v2\n                        p2 = (threshold_function(tt[i]-eps) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n\n                    term1 = 2*np.pi * iv(0, 2*c1 * drift_vec[i, 1]/c2)\n                    term2 = (1/(np.sqrt(s_v2 * (tt[i] - eps) + 1)))**3\n                    p1 = (c1**2 + drift_vec[i, 1]**2)/c2\n                    p3 = (norm_mu[i]**2)/(2*s_v2)\n                    term3 = np.exp(p1 + p2 - p3)\n                    integrand = term1 * term2 * term3 * np.interp(tt[i]-eps, T, fpt_z)/s_t\n\n                    density = trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                            log_density[i] = np.log(density)\n\n    log_density[rt - ndt &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.ProjectedSphericalDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate response times and choices from the Projected Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>array - like</code> <p>The drift vector should be of shape (2,)</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>Time step for the simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>Number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate response times and choices from the Projected Spherical Diffusion Model\n\n    Parameters\n    ----------\n    drift_vec : array-like\n        The drift vector should be of shape (2,)\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        Time step for the simulation (default is 0.001)\n    n_sample : int, optional\n        Number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''    \n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample,))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 2))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_PSDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n],\n                                                   threshold_dynamic=self.threshold_dynamic,\n                                                   decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_custom_threshold_PSDM_trial(threshold_function,\n                                                                    drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                    s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response'])\n</code></pre>"},{"location":"api/#CRDDM.SphericalDiffusionModel","title":"<code>SphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.SphericalDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angles</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>(array - like, shape(n_samples))</code> <p>The response times</p> required <code>theta</code> <code>(array - like, shape(n_samples, 2))</code> <p>The choice angles in spherical coordinates (theta1, theta2)</p> required <code>drift_vec</code> <code>(array - like, shape(3) or (n_samples, 3))</code> <p>The drift rates in each dimension</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> required <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>log_density</code> <code>(array - like, shape(n_samples))</code> <p>The joint log-probability density of response time and choice angles</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1):\n    '''\n    Compute the joint log-probability density function of response time and choice angles\n\n    Parameters\n    ----------\n    rt : array-like, shape (n_samples,)\n        The response times\n    theta : array-like, shape (n_samples, 2)\n        The choice angles in spherical coordinates (theta1, theta2)\n    drift_vec : array-like, shape (3,) or (n_samples, 3)\n        The drift rates in each dimension\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n\n    Returns\n    -------\n    log_density : array-like, shape (n_samples,)\n        The joint log-probability density of response time and choice angles\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 3))\n\n    if drift_vec.shape[1] != 3 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (3,) or (n_samples, 3)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)   \n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)   \n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 3, 0.000001, dt=0.02, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        mu_dot_x0 = drift_vec[:, 0]*np.cos(theta[:, 0])\n        mu_dot_x1 = drift_vec[:, 1]*np.sin(theta[:, 0])*np.cos(theta[:, 1]) \n        mu_dot_x2 = drift_vec[:, 2]*np.sin(theta[:, 0])*np.sin(theta[:, 1])\n\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = a * (mu_dot_x0 + mu_dot_x1 + mu_dot_x2) / sigma**2\n            term2 = 0.5 * (drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2) * tt\n            log_density = term1 - term2 + np.log(fpt_z) - np.log(4*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            norm2_drift = drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2\n            mu_dot_x = (mu_dot_x0 + mu_dot_x1 + mu_dot_x2) / sigma**2\n\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        integrand = np.exp(- 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * np.exp(threshold * mu_dot_x[i]) * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        integrand = np.exp((threshold - decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        integrand = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        integrand = np.exp(threshold/(1  + decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        integrand = np.exp(threshold_function(tt[i] - eps) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n    else:\n        # With drift variability\n        if s_t == 0:\n            # No non-decision time variability\n            s_v2 = s_v**2\n            x0 =  a * np.cos(theta[:, 0])\n            x1 =  a * np.sin(theta[:, 0])*np.cos(theta[:, 1]) \n            x2 =  a * np.sin(theta[:, 0])*np.sin(theta[:, 1])\n            fixed = 1/(np.sqrt(s_v2 * tt + 1))\n            exponent0 = -0.5*drift_vec[:, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[:, 0])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent1 = -0.5*drift_vec[:, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[:, 1])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent2 = -0.5*drift_vec[:, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[:, 2])**2 / (s_v2 * (s_v2 * tt + 1))\n            log_density = 3*np.log(fixed) + exponent0 + exponent1 + exponent2 + np.log(fpt_z) - np.log(4*np.pi)\n        else:\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        x0 = threshold * np.cos(theta[i, 0])\n                        x1 = threshold * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = threshold * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'linear':\n                        x0 = (threshold - decay * (tt[i]-eps)) * np.cos(theta[i, 0])\n                        x1 = (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'exponential':\n                        x0 = (threshold * np.exp(-decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 = (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        x0 = (threshold / (1 + decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 = (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'custom':\n                        x0 = threshold_function(tt[i]-eps) * np.cos(theta[i, 0])\n                        x1 = threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    fixed = 1/(np.sqrt(s_v2 * (tt[i] - eps) + 1))\n                    exponent0 = -0.5*drift_vec[i, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[i, 0])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent1 = -0.5*drift_vec[i, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[i, 1])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent2 = -0.5*drift_vec[i, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[i, 2])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n\n                    integrand = fixed**3 * np.exp(exponent0 + exponent1 + exponent2) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                    density = 1/(4*np.pi) * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    log_density[rt - ndt &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.SphericalDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate data from the Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>array - like</code> <p>Drift vector; a three-dimensional array</p> required <code>ndt</code> <code>float</code> <p>Non-decision time; a positive floating number</p> required <code>threshold</code> <code>float</code> <p>Decision threshold; a positive floating number (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>Decay rate of the collapsing boundary (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>Time step for the simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>Number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate data from the Spherical Diffusion Model\n\n    Parameters\n    ----------\n    drift_vec : array-like\n        Drift vector; a three-dimensional array\n    ndt : float\n        Non-decision time; a positive floating number\n    threshold : float\n        Decision threshold; a positive floating number (default is 1)\n    decay : float, optional\n        Decay rate of the collapsing boundary (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        Time step for the simulation (default is 0.001)\n    n_sample : int, optional\n        Number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''\n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample, 2))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 3))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_SDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n], \n                                                     threshold_dynamic=self.threshold_dynamic, \n                                                     decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_custom_threshold_SDM_trial(threshold_function,\n                                                                      drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                      s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response1', 'response2'])\n</code></pre>"},{"location":"api/#CRDDM.iv_numba","title":"<code>iv_numba(v, x)</code>","text":"<p>Modified Bessel function of the first kind I_v(x) for real v and real x. Uses series for small x and asymptotic for large x.</p> <p>WARNING: I_v(x) grows like exp(x)/sqrt(x), so iv_numba will overflow to inf for sufficiently large x (around x &gt; ~709 in float64).</p> Source code in <code>CRDDM/utility/helpers.py</code> <pre><code>@jit(nopython=False)\ndef iv_numba(v, x):\n    \"\"\"\n    Modified Bessel function of the first kind I_v(x) for real v and real x.\n    Uses series for small x and asymptotic for large x.\n\n    WARNING: I_v(x) grows like exp(x)/sqrt(x), so iv_numba will overflow to inf\n    for sufficiently large x (around x &gt; ~709 in float64).\n    \"\"\"\n    ax = np.abs(x)\n    if ax == 0.0:\n        if v == 0.0:\n            return 1.0\n        return 0.0\n\n    if ax &lt; 18.0:\n        return _iv_series(v, ax)\n    else:\n        # Use ive asymptotic then multiply by exp(ax) if safe\n        scaled = _ive_asymptotic(v, ax)\n        # exp(709.78...) is near float64 max\n        if ax &gt; 709.0:\n            return np.inf\n        return scaled * np.exp(ax)\n</code></pre>"},{"location":"api/#CRDDM.ive_numba","title":"<code>ive_numba(v, x)</code>","text":"<p>Exponentially scaled modified Bessel I:   ive(v,x) = exp(-abs(x)) * I_v(x) for real v and real x.</p> <p>This implementation assumes x &gt;= 0 for best behavior.</p> Source code in <code>CRDDM/utility/helpers.py</code> <pre><code>@jit(nopython=False)\ndef ive_numba(v, x):\n    \"\"\"\n    Exponentially scaled modified Bessel I:\n      ive(v,x) = exp(-abs(x)) * I_v(x)\n    for real v and real x.\n\n    This implementation assumes x &gt;= 0 for best behavior.\n    \"\"\"\n    ax = np.abs(x)\n    if ax == 0.0:\n        # ive(v,0) = I_v(0)\n        if v == 0.0:\n            return 1.0\n        return 0.0\n\n    # Threshold where asymptotic is usually accurate and faster than the series\n    if ax &lt; 18.0:\n        # compute I_v(ax) then scale\n        iv = _iv_series(v, ax)\n        return iv * np.exp(-ax)\n    else:\n        return _ive_asymptotic(v, ax)\n</code></pre>"},{"location":"api/#CRDDM.load_fennell2023","title":"<code>load_fennell2023()</code>","text":"<p>Load data from experiment one in Fennell and Ratcliff (2023).</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing the data with columns: 'subjectNumber', 'blockNumber', 'trialNumber', 'rt', 'numberOfStimulus', 'responseError'</p> Source code in <code>CRDDM/utility/datasets.py</code> <pre><code>def load_fennell2023():\n    '''\n    Load data from experiment one in Fennell and Ratcliff (2023).\n\n    Returns\n    -------\n    pd.DataFrame\n        A dataframe containing the data with columns: 'subjectNumber', 'blockNumber', 'trialNumber', 'rt', 'numberOfStimulus', 'responseError'\n    '''\n\n    data_path = os.path.join(os.path.dirname(os.path.dirname(__dir__)), \"data\", \"Fennell2023_exp4.csv\")\n\n    data = pd.read_csv(data_path, index_col=0)\n    return data\n</code></pre>"},{"location":"api/#CRDDM.load_kvam2019","title":"<code>load_kvam2019()</code>","text":"<p>Load data from Kvam et al. (2019).</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A dataframe containing the data with columns:</p> Source code in <code>CRDDM/utility/datasets.py</code> <pre><code>def load_kvam2019():\n    '''\n    Load data from Kvam et al. (2019).\n\n    Returns\n    -------\n    pd.DataFrame\n        A dataframe containing the data with columns: \n    '''\n\n    data_path = os.path.join(os.path.dirname(os.path.dirname(__dir__)), \"data\", \"Kvam2019.csv\")\n\n    data = pd.read_csv(data_path)\n\n    data = data.drop(columns=['isCued', 'cueOrientation', \n                                'cueDeflections', 'points', \n                                'jitterLevel', 'targetOrientation'])\n    data = data.rename(columns={'RT':'rt'})\n    data.deviation *= 2\n    data.absoluteDeviation = np.abs(data.deviation)\n    return data\n</code></pre>"},{"location":"api/#CRDDM.simulate_CDM_trial","title":"<code>simulate_CDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold: a positive floating number     drift_vec: drift vector; a two-dimensional array     ndt: a positive floating number     threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')     decay: decay rate of the collapsing boundary     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: response angle between [-pi, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>@jit(nopython=True)\ndef simulate_CDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold: a positive floating number\n        drift_vec: drift vector; a two-dimensional array\n        ndt: a positive floating number\n        threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')\n        decay: decay rate of the collapsing boundary\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: response angle between [-pi, pi]\n    '''\n    x = np.zeros((2,))\n\n    rt = 0\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand()\n    else:\n        ndt_t = ndt\n\n    if s_v&gt;0:\n        mu_t = drift_vec + s_v*np.random.randn(2)\n    else:\n        mu_t = drift_vec\n\n    if threshold_dynamic == 'fixed':\n        while np.linalg.norm(x) &lt; threshold:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(2)\n            rt += dt\n    elif threshold_dynamic == 'linear':\n        while np.linalg.norm(x) &lt; threshold - decay*rt:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(2)\n            rt += dt\n    elif threshold_dynamic == 'exponential':\n        while np.linalg.norm(x) &lt; threshold * np.exp(-decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(2)\n            rt += dt\n    elif threshold_dynamic == 'hyperbolic':\n        while np.linalg.norm(x) &lt; threshold / (1 + decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(2)\n            rt += dt\n    theta = np.arctan2(x[1], x[0]) \n    return ndt_t+rt, theta\n</code></pre>"},{"location":"api/#CRDDM.simulate_HSDM_trial","title":"<code>simulate_HSDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold: a positive floating number     drift_vec: drift vector; a four-dimensional array     ndt: a positive floating number     threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')     decay: decay rate of the collapsing boundary     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: a tuple of response angles (theta1, theta2, theta3); theta1 and theta2 between [0, pi], and theta3 between [-pi, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>@jit(nopython=True)\ndef simulate_HSDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold: a positive floating number\n        drift_vec: drift vector; a four-dimensional array\n        ndt: a positive floating number\n        threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')\n        decay: decay rate of the collapsing boundary\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: a tuple of response angles (theta1, theta2, theta3); theta1 and theta2 between [0, pi], and theta3 between [-pi, pi]\n    '''\n    x = np.zeros((4,))\n\n    rt = 0\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand()\n    else:\n        ndt_t = ndt\n\n    if s_v&gt;0:\n        mu_t = drift_vec + s_v*np.random.randn(4)\n    else:\n        mu_t = drift_vec\n\n    if threshold_dynamic == 'fixed':\n        while np.linalg.norm(x) &lt; threshold:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(4)\n            rt += dt\n    elif threshold_dynamic == 'linear':\n        while np.linalg.norm(x) &lt; threshold - decay*rt:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(4)\n            rt += dt\n    elif threshold_dynamic == 'exponential':\n        while np.linalg.norm(x) &lt; threshold * np.exp(-decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(4)\n            rt += dt\n    elif threshold_dynamic == 'hyperbolic':\n        while np.linalg.norm(x) &lt; threshold / (1 + decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(4)\n            rt += dt\n\n    theta1 = np.arctan2(np.sqrt(x[3]**2 + x[2]**2 + x[1]**2), x[0])\n    theta2 = np.arctan2(np.sqrt(x[3]**2 + x[2]**2), x[1])\n    theta3 = np.arctan2(x[3], x[2])\n\n    return ndt_t+rt, (theta1, theta2, theta3)\n</code></pre>"},{"location":"api/#CRDDM.simulate_PHSDM_trial","title":"<code>simulate_PHSDM_trial(threshold, drift_vec, ndt, decay=0, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold: a positive floating number     drift_vec: drift vector; a three-dimensional array     ndt: a positive floating number     decay: decay rate of the collapsing boundary     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: response angle between [0, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>@jit(nopython=True)\ndef simulate_PHSDM_trial(threshold, drift_vec, ndt, decay=0, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold: a positive floating number\n        drift_vec: drift vector; a three-dimensional array\n        ndt: a positive floating number\n        decay: decay rate of the collapsing boundary\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: response angle between [0, pi]\n    '''\n    pass  # to be implemented later\n</code></pre>"},{"location":"api/#CRDDM.simulate_PSDM_trial","title":"<code>simulate_PSDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold: a positive floating number     drift_vec: drift vector; a two-dimensional array     ndt: a positive floating number     threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')     decay: decay rate of the collapsing boundary     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: response angle between [0, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>@jit(nopython=True)\ndef simulate_PSDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold: a positive floating number\n        drift_vec: drift vector; a two-dimensional array\n        ndt: a positive floating number\n        threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')\n        decay: decay rate of the collapsing boundary\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: response angle between [0, pi]\n    '''\n    x = np.zeros((3,))\n    muz = drift_vec[0]\n    eta = drift_vec[1]\n\n    norm_mu = np.sqrt(eta**2 + muz**2)\n    theta_mu = np.arctan2(eta, muz)\n\n    rt = 0\n    rphi = np.pi/4 # it is not important (just a dummpy value)\n    mux = norm_mu * np.sin(theta_mu) * np.cos(rphi)\n    muy = norm_mu * np.sin(theta_mu) * np.sin(rphi)\n\n    mu = np.array([mux, muy, muz])\n\n    if s_v&gt;0:\n        mu_t = mu + s_v*np.random.randn(3)\n    else:\n        mu_t = mu\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand()\n    else:\n        ndt_t = ndt\n\n    if threshold_dynamic == 'fixed':\n        while np.sqrt(x[0]**2 + x[1]**2 + x[2]**2) &lt; threshold:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n    elif threshold_dynamic == 'linear':\n        while np.sqrt(x[0]**2 + x[1]**2 + x[2]**2) &lt; threshold - decay*rt:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n    elif threshold_dynamic == 'exponential':\n        while np.sqrt(x[0]**2 + x[1]**2 + x[2]**2) &lt; threshold * np.exp(-decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n    elif threshold_dynamic == 'hyperbolic':\n        while np.sqrt(x[0]**2 + x[1]**2 + x[2]**2) &lt; threshold / (1 + decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n\n    theta = np.arctan2(np.sqrt(x[0]**2 + x[1]**2), x[2])    \n\n    return ndt_t+rt, theta\n</code></pre>"},{"location":"api/#CRDDM.simulate_SDM_trial","title":"<code>simulate_SDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold: a positive floating number     drift_vec: drift vector; a three-dimensional array     ndt: a positive floating number     threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')     decay: decay rate of the collapsing boundary     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: a tuple of response angles (theta1, theta2); theta 1 between [0, pi] and theta2 between [-pi, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>@jit(nopython=True)\ndef simulate_SDM_trial(threshold, drift_vec, ndt, threshold_dynamic='fixed', decay=0, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold: a positive floating number\n        drift_vec: drift vector; a three-dimensional array\n        ndt: a positive floating number\n        threshold_dynamic: type of threshold collapse ('fixed', 'linear', 'exponential', or 'hyperbolic')\n        decay: decay rate of the collapsing boundary\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: a tuple of response angles (theta1, theta2); theta 1 between [0, pi] and theta2 between [-pi, pi]\n    '''\n    x = np.zeros((3,))\n\n    rt = 0\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand()\n    else:\n        ndt_t = ndt\n\n    if s_v&gt;0:\n        mu_t = drift_vec + s_v*np.random.randn(3)\n    else:\n        mu_t = drift_vec\n\n    if threshold_dynamic == 'fixed':\n        while np.linalg.norm(x) &lt; threshold:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n    elif threshold_dynamic == 'linear':\n        while np.linalg.norm(x) &lt; threshold - decay*rt:\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n    elif threshold_dynamic == 'exponential':\n        while np.linalg.norm(x) &lt; threshold * np.exp(-decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n    elif threshold_dynamic == 'hyperbolic':\n        while np.linalg.norm(x) &lt; threshold / (1 + decay*rt):\n            x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n            rt += dt\n\n    theta1 = np.arctan2(np.sqrt(x[2]**2 + x[1]**2), x[0])\n    theta2 = np.arctan2(x[2], x[1])\n\n    return ndt_t+rt, (theta1, theta2)\n</code></pre>"},{"location":"api/#CRDDM.simulate_custom_threshold_CDM_trial","title":"<code>simulate_custom_threshold_CDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold_function: a function that takes time t and returns the threshold at time t     drift_vec: drift vector; a two-dimensional array     ndt: a positive floating number     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: response angle between [-pi, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>def simulate_custom_threshold_CDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold_function: a function that takes time t and returns the threshold at time t\n        drift_vec: drift vector; a two-dimensional array\n        ndt: a positive floating number\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: response angle between [-pi, pi]\n    '''\n    x = np.zeros((2,))\n\n    rt = 0\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand() - s_t\n    else:\n        ndt_t = ndt\n\n    if s_v&gt;0:\n        mu_t = drift_vec + s_v*np.random.randn(2)\n    else:\n        mu_t = drift_vec\n\n    while np.linalg.norm(x) &lt; threshold_function(rt):\n        x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(2)\n        rt += dt\n\n    theta = np.arctan2(x[1], x[0]) \n\n    return ndt_t+rt, theta\n</code></pre>"},{"location":"api/#CRDDM.simulate_custom_threshold_HSDM_trial","title":"<code>simulate_custom_threshold_HSDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold_function: a function that takes time and returns the threshold at that time     drift_vec: drift vector; a four-dimensional array     ndt: a positive floating number     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: a tuple of response angles (theta1, theta2, theta3); theta1 and theta2 between [0, pi], and theta3 between [-pi, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>def simulate_custom_threshold_HSDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold_function: a function that takes time and returns the threshold at that time\n        drift_vec: drift vector; a four-dimensional array\n        ndt: a positive floating number\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: a tuple of response angles (theta1, theta2, theta3); theta1 and theta2 between [0, pi], and theta3 between [-pi, pi]\n    '''\n    x = np.zeros((4,))\n\n    rt = 0\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand()\n    else:\n        ndt_t = ndt\n\n    if s_v&gt;0:\n        mu_t = drift_vec + s_v*np.random.randn(4)\n    else:\n        mu_t = drift_vec\n\n    while np.linalg.norm(x) &lt; threshold_function(rt):\n        x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(4)\n        rt += dt\n\n    theta1 = np.arctan2(np.sqrt(x[3]**2 + x[2]**2 + x[1]**2), x[0])\n    theta2 = np.arctan2(np.sqrt(x[3]**2 + x[2]**2), x[1])\n    theta3 = np.arctan2(x[3], x[2])\n\n    return ndt_t+rt, (theta1, theta2, theta3)\n</code></pre>"},{"location":"api/#CRDDM.simulate_custom_threshold_PSDM_trial","title":"<code>simulate_custom_threshold_PSDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold_function: a function that takes time and returns threshold     drift_vec: drift vector; a two-dimensional array     ndt: a positive floating number     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: response angle between [0, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>def simulate_custom_threshold_PSDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold_function: a function that takes time and returns threshold\n        drift_vec: drift vector; a two-dimensional array\n        ndt: a positive floating number\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: response angle between [0, pi]\n    '''\n    x = np.zeros((3,))\n    muz = drift_vec[0]\n    eta = drift_vec[1]\n\n    norm_mu = np.sqrt(eta**2 + muz**2)\n    theta_mu = np.arctan2(eta, muz)\n\n    rt = 0\n    rphi = np.pi/4 # it is not important (just a dummpy value)\n    mux = norm_mu * np.sin(theta_mu) * np.cos(rphi)\n    muy = norm_mu * np.sin(theta_mu) * np.sin(rphi)\n\n    mu = np.array([mux, muy, muz])\n\n    if s_v&gt;0:\n        mu_t = mu + s_v*np.random.randn(3)\n    else:\n        mu_t = mu\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand()\n    else:\n        ndt_t = ndt\n\n    while np.sqrt(x[0]**2 + x[1]**2 + x[2]**2) &lt; threshold_function(rt):\n        x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n\n        rt += dt\n\n    theta = np.arctan2(np.sqrt(x[0]**2 + x[1]**2), x[2])    \n\n    return ndt_t+rt, theta\n</code></pre>"},{"location":"api/#CRDDM.simulate_custom_threshold_SDM_trial","title":"<code>simulate_custom_threshold_SDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001)</code>","text":"<p>input:     threshold_function: a function that takes time t and returns the threshold at time t     drift_vec: drift vector; a three-dimensional array     ndt: a positive floating number     s_v: standard deviation of drift rate variability     s_t: range of non-decision time variability     sigma: standard deviation of the diffusion process     dt: time step for the simulation returns:     rt: response time in seconds     theta: a tuple of response angles (theta1, theta2); theta 1 between [0, pi] and theta2 between [-pi, pi]</p> Source code in <code>CRDDM/utility/simulators.py</code> <pre><code>def simulate_custom_threshold_SDM_trial(threshold_function, drift_vec, ndt, s_v=0, s_t=0, sigma=1, dt=0.001):\n    '''\n    input:\n        threshold_function: a function that takes time t and returns the threshold at time t\n        drift_vec: drift vector; a three-dimensional array\n        ndt: a positive floating number\n        s_v: standard deviation of drift rate variability\n        s_t: range of non-decision time variability\n        sigma: standard deviation of the diffusion process\n        dt: time step for the simulation\n    returns:\n        rt: response time in seconds\n        theta: a tuple of response angles (theta1, theta2); theta 1 between [0, pi] and theta2 between [-pi, pi]\n    '''\n    x = np.zeros((3,))\n\n    rt = 0\n\n    if s_t&gt;0:\n        ndt_t = ndt + s_t*np.random.rand()\n    else:\n        ndt_t = ndt\n\n    if s_v&gt;0:\n        mu_t = drift_vec + s_v*np.random.randn(3)\n    else:\n        mu_t = drift_vec\n\n    while np.linalg.norm(x) &lt; threshold_function(rt):\n        x += mu_t*dt + sigma*np.sqrt(dt)*np.random.randn(3)\n        rt += dt\n\n    theta1 = np.arctan2(np.sqrt(x[2]**2 + x[1]**2), x[0])\n    theta2 = np.arctan2(x[2], x[1])\n\n    return ndt_t+rt, (theta1, theta2)\n</code></pre>"},{"location":"api/#CRDDM.trapz_1d","title":"<code>trapz_1d(y, x)</code>","text":"<p>Trapezoidal integral of y over x. Both 1D, same length.</p> Source code in <code>CRDDM/utility/helpers.py</code> <pre><code>@njit(cache=True, fastmath=True)\ndef trapz_1d(y, x):\n    \"\"\"\n    Trapezoidal integral of y over x. Both 1D, same length.\n    \"\"\"\n    s = 0.0\n    for i in range(x.shape[0] - 1):\n        dx = x[i + 1] - x[i]\n        s += 0.5 * (y[i] + y[i + 1]) * dx\n    return s\n</code></pre>"},{"location":"api/#models","title":"Models","text":""},{"location":"api/#circular-diffusion-model","title":"Circular diffusion model","text":""},{"location":"api/#CRDDM.Models.Circular.CircularDiffusionModel","title":"<code>CircularDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Circular Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/Circular.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Circular Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.Models.Circular.CircularDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.01)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angle</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>array - like</code> <p>Response times</p> required <code>theta</code> <code>array - like</code> <p>Choice angles in radians</p> required <code>drift_vec</code> <code>(array - like, shape(2) or (n_samples, 2))</code> <p>The drift vector [drift_x, drift_y]</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The initial decision threshold</p> required <code>decay</code> <code>float</code> <p>The decay rate of the threshold (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>The time step for numerical estimation of first-passage time densities (default is 0.01)</p> <code>0.01</code> <p>Returns:</p> Type Description <code>array - like</code> <p>The joint log-probability density evaluated at (rt, theta) with same shape as rt and theta</p> Source code in <code>CRDDM/Models/Circular.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.01):\n    '''\n    Compute the joint log-probability density function of response time and choice angle\n\n    Parameters\n    ----------\n    rt : array-like\n        Response times\n    theta : array-like\n        Choice angles in radians\n    drift_vec : array-like, shape (2,) or (n_samples, 2)\n        The drift vector [drift_x, drift_y]\n    ndt : float\n        The non-decision time\n    threshold : float\n        The initial decision threshold\n    decay : float\n        The decay rate of the threshold (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        The time step for numerical estimation of first-passage time densities (default is 0.01)\n\n    Returns\n    -------\n    array-like\n        The joint log-probability density evaluated at (rt, theta) with same shape as rt and theta\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 2))\n\n    if drift_vec.shape[1] != 2 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (2,) or (n_samples, 2)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = cdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * cdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)   \n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = cdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * cdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)   \n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 2, 0.000001, dt=dt, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 2, 0.000001, dt=dt, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 2, 0.000001, dt=dt, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 2, 0.000001, dt=dt, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        mu_dot_x0 = drift_vec[:, 0] * np.cos(theta)\n        mu_dot_x1 = drift_vec[:, 1] * np.sin(theta)\n\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = a * (mu_dot_x0 + mu_dot_x1) / sigma**2\n            term2 = 0.5 * (drift_vec[:, 0]**2 + drift_vec[:, 1]**2) * tt\n            log_density = term1 - term2 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            norm2_drift = drift_vec[:, 0]**2 + drift_vec[:, 1]**2\n            mu_dot_x = (mu_dot_x0 + mu_dot_x1) / sigma**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        integrand = np.exp(- 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * np.exp(threshold * mu_dot_x[i]) * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        integrand = np.exp((threshold - decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        integrand = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        integrand = np.exp(threshold/(1  + decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        integrand = np.exp(threshold_function(tt[i] - eps) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    else:\n        # With drift variability\n        if s_t == 0:\n            # No non-decision time variability     \n            s_v2 = s_v**2\n            x0 =  a * np.cos(theta)\n            x1 =  a * np.sin(theta)\n            fixed = 1/(np.sqrt(s_v2 * tt + 1))\n            exponent0 = -0.5*drift_vec[:, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[:, 0])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent1 = -0.5*drift_vec[:, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[:, 1])**2 / (s_v2 * (s_v2 * tt + 1))\n\n            log_density = 2*np.log(fixed) + exponent0 + exponent1 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        x0 =  threshold * np.cos(theta[i])\n                        x1 =  threshold * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'linear':\n                        x0 =  (threshold - decay * (tt[i]-eps)) * np.cos(theta[i])\n                        x1 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'exponential':\n                        x0 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.cos(theta[i])\n                        x1 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        x0 =  (threshold / (1 + decay * (tt[i]-eps))) * np.cos(theta[i])\n                        x1 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i])\n                    elif self.threshold_dynamic == 'custom':\n                        x0 =  threshold_function(tt[i]-eps) * np.cos(theta[i])\n                        x1 =  threshold_function(tt[i]-eps) * np.sin(theta[i])\n                    fixed = 1/(np.sqrt(s_v2 * (tt[i]-eps) + 1))\n                    exponent0 = -0.5*drift_vec[i, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[i, 0])**2 / (s_v2 * (s_v2 * (tt[i]-eps) + 1))\n                    exponent1 = -0.5*drift_vec[i, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[i, 1])**2 / (s_v2 * (s_v2 * (tt[i]-eps) + 1))\n\n                    integrand = fixed**2 * np.exp(exponent0 + exponent1) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                    density = 1/(2*np.pi) * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    log_density[rt - ndt - s_t &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.Models.Circular.CircularDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate data from the Circular Diffusion Model with collapsing boundaries</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>(array - like, shape(2))</code> <p>The drift vector [drift_x, drift_y]</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The initial decision threshold (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>The decay rate of the threshold (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>The time step for simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>The number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/Circular.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate data from the Circular Diffusion Model with collapsing boundaries\n\n    Parameters\n    ----------\n    drift_vec : array-like, shape (2,)\n        The drift vector [drift_x, drift_y]\n    ndt : float\n        The non-decision time\n    threshold : float\n        The initial decision threshold (default is 1)\n    decay : float\n        The decay rate of the threshold (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        The time step for simulation (default is 0.001)\n    n_sample : int, optional\n        The number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''\n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample,))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 2))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_CDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n], \n                                                  threshold_dynamic=self.threshold_dynamic,\n                                                  decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_custom_threshold_CDM_trial(threshold_function,\n                                                                   drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                   s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response'])\n</code></pre>"},{"location":"api/#spherical-diffusion-models","title":"Spherical diffusion models","text":""},{"location":"api/#CRDDM.Models.Spherical.ProjectedSphericalDiffusionModel","title":"<code>ProjectedSphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Projected Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Projected Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.Models.Spherical.ProjectedSphericalDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angle</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>(array - like, shape(n_samples))</code> <p>The response times</p> required <code>theta</code> <code>(array - like, shape(n_samples))</code> <p>The choice angles in radians</p> required <code>drift_vec</code> <code>(array - like, shape(2) or (n_samples, 2))</code> <p>The drift vector [drift_x, drift_y]</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> required <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>log_density</code> <code>(array - like, shape(n_samples))</code> <p>The joint log-probability density of response time and choice angle</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1):\n    '''\n    Compute the joint log-probability density function of response time and choice angle\n\n    Parameters\n    ----------\n    rt : array-like, shape (n_samples,)\n        The response times\n    theta : array-like, shape (n_samples,)\n        The choice angles in radians\n    drift_vec : array-like, shape (2,) or (n_samples, 2)\n        The drift vector [drift_x, drift_y]\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n\n    Returns\n    -------\n    log_density : array-like, shape (n_samples,)\n        The joint log-probability density of response time and choice angle\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 2))\n\n    if drift_vec.shape[1] != 2 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (2,) or (n_samples, 2)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)   \n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)   \n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 3, 0.000001, dt=0.02, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    norm_mu = np.sqrt(drift_vec[:, 0]**2 + drift_vec[:, 1]**2)\n    theta_mu = np.arctan2(drift_vec[:, 1], drift_vec[:, 0])\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = np.exp(a * norm_mu * np.cos(theta_mu) * np.cos(theta))\n            term2 = iv(0, a * norm_mu * np.sin(theta_mu) * np.sin(theta))\n            term3 = -0.5 * norm_mu**2 * tt\n            log_density = np.log(2*np.pi) + np.log(term1) + np.log(term2) + term3 + np.log(fpt_z)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        term1 = np.exp(threshold * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * term1 * term2 * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        term1 = np.exp((threshold - decay * (tt[i] - eps)) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, (threshold - decay * (tt[i] - eps)) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        term1 = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold*np.exp(-decay * (tt[i] - eps)) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        term1 = np.exp(threshold/(1  + decay * (tt[i] - eps)) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold/(1  + decay * (tt[i] - eps)) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        term1 = np.exp(threshold_function(tt[i] - eps) * norm_mu[i] * np.cos(theta_mu[i]) * np.cos(theta[i]))\n                        term2 = iv(0, threshold_function(tt[i] - eps) * norm_mu[i] * np.sin(theta_mu[i]) * np.sin(theta[i]))\n                        term3 = -0.5 * norm_mu[i]**2 * (tt[i] - eps)\n                        integrand = term1 * term2 * np.exp(term3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 2*np.pi * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n    else:\n        # With drift variability\n        if s_t == 0:\n            # No non-decision time variability\n            s_v2 = s_v**2\n            c1 = a * np.sin(theta) * s_v2\n            c2 = 2*s_v2 * (s_v2 * tt + 1)\n            term1 = 2*np.pi * iv(0, 2*c1 * drift_vec[:, 1]/c2)\n            term2 = (1/(np.sqrt(s_v2 * tt + 1)))**3\n            p1 = (c1**2 + drift_vec[:, 1]**2)/c2\n            p2 = (a * np.cos(theta) * s_v2 + drift_vec[:, 0])**2 / c2\n            p3 = (norm_mu**2)/(2*s_v2)\n            term3 = np.exp(p1 + p2 - p3)\n\n            log_density = np.log(term1) + np.log(term2) + np.log(term3) + np.log(fpt_z)\n        else:\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    c2 = 2*s_v2 * (s_v2 * (tt[i] - eps) + 1)\n                    if self.threshold_dynamic == 'fixed':\n                        c1 = threshold * np.sin(theta[i]) * s_v2\n                        p2 = (threshold * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'linear':\n                        c1 = (threshold - decay*(tt[i]-eps)) * np.sin(theta[i]) * s_v2\n                        p2 = ((threshold - decay*(tt[i]-eps)) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'exponential':\n                        c1 = (threshold * np.exp(-decay*(tt[i]-eps))) * np.sin(theta[i]) * s_v2\n                        p2 = ((threshold * np.exp(-decay*(tt[i]-eps))) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        c1 = (threshold / (1 + decay*(tt[i]-eps))) * np.sin(theta[i]) * s_v2\n                        p2 = ((threshold / (1 + decay*(tt[i]-eps))) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n                    elif self.threshold_dynamic == 'custom':\n                        c1 = threshold_function(tt[i]-eps) * np.sin(theta[i]) * s_v2\n                        p2 = (threshold_function(tt[i]-eps) * np.cos(theta[i]) * s_v2 + drift_vec[i, 0])**2 / c2\n\n                    term1 = 2*np.pi * iv(0, 2*c1 * drift_vec[i, 1]/c2)\n                    term2 = (1/(np.sqrt(s_v2 * (tt[i] - eps) + 1)))**3\n                    p1 = (c1**2 + drift_vec[i, 1]**2)/c2\n                    p3 = (norm_mu[i]**2)/(2*s_v2)\n                    term3 = np.exp(p1 + p2 - p3)\n                    integrand = term1 * term2 * term3 * np.interp(tt[i]-eps, T, fpt_z)/s_t\n\n                    density = trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                            log_density[i] = np.log(density)\n\n    log_density[rt - ndt &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.Models.Spherical.ProjectedSphericalDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate response times and choices from the Projected Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>array - like</code> <p>The drift vector should be of shape (2,)</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>Time step for the simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>Number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate response times and choices from the Projected Spherical Diffusion Model\n\n    Parameters\n    ----------\n    drift_vec : array-like\n        The drift vector should be of shape (2,)\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        Time step for the simulation (default is 0.001)\n    n_sample : int, optional\n        Number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''    \n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample,))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 2))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_PSDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n],\n                                                   threshold_dynamic=self.threshold_dynamic,\n                                                   decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n] = simulate_custom_threshold_PSDM_trial(threshold_function,\n                                                                    drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                    s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response'])\n</code></pre>"},{"location":"api/#CRDDM.Models.Spherical.SphericalDiffusionModel","title":"<code>SphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.Models.Spherical.SphericalDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angles</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>(array - like, shape(n_samples))</code> <p>The response times</p> required <code>theta</code> <code>(array - like, shape(n_samples, 2))</code> <p>The choice angles in spherical coordinates (theta1, theta2)</p> required <code>drift_vec</code> <code>(array - like, shape(3) or (n_samples, 3))</code> <p>The drift rates in each dimension</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> required <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>log_density</code> <code>(array - like, shape(n_samples))</code> <p>The joint log-probability density of response time and choice angles</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1):\n    '''\n    Compute the joint log-probability density function of response time and choice angles\n\n    Parameters\n    ----------\n    rt : array-like, shape (n_samples,)\n        The response times\n    theta : array-like, shape (n_samples, 2)\n        The choice angles in spherical coordinates (theta1, theta2)\n    drift_vec : array-like, shape (3,) or (n_samples, 3)\n        The drift rates in each dimension\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n\n    Returns\n    -------\n    log_density : array-like, shape (n_samples,)\n        The joint log-probability density of response time and choice angles\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 3))\n\n    if drift_vec.shape[1] != 3 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (3,) or (n_samples, 3)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)   \n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = sdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * sdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)   \n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 3, 0.000001, dt=0.02, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 3, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        mu_dot_x0 = drift_vec[:, 0]*np.cos(theta[:, 0])\n        mu_dot_x1 = drift_vec[:, 1]*np.sin(theta[:, 0])*np.cos(theta[:, 1]) \n        mu_dot_x2 = drift_vec[:, 2]*np.sin(theta[:, 0])*np.sin(theta[:, 1])\n\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = a * (mu_dot_x0 + mu_dot_x1 + mu_dot_x2) / sigma**2\n            term2 = 0.5 * (drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2) * tt\n            log_density = term1 - term2 + np.log(fpt_z) - np.log(4*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            norm2_drift = drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2\n            mu_dot_x = (mu_dot_x0 + mu_dot_x1 + mu_dot_x2) / sigma**2\n\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        integrand = np.exp(- 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * np.exp(threshold * mu_dot_x[i]) * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        integrand = np.exp((threshold - decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        integrand = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        integrand = np.exp(threshold/(1  + decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        integrand = np.exp(threshold_function(tt[i] - eps) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n    else:\n        # With drift variability\n        if s_t == 0:\n            # No non-decision time variability\n            s_v2 = s_v**2\n            x0 =  a * np.cos(theta[:, 0])\n            x1 =  a * np.sin(theta[:, 0])*np.cos(theta[:, 1]) \n            x2 =  a * np.sin(theta[:, 0])*np.sin(theta[:, 1])\n            fixed = 1/(np.sqrt(s_v2 * tt + 1))\n            exponent0 = -0.5*drift_vec[:, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[:, 0])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent1 = -0.5*drift_vec[:, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[:, 1])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent2 = -0.5*drift_vec[:, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[:, 2])**2 / (s_v2 * (s_v2 * tt + 1))\n            log_density = 3*np.log(fixed) + exponent0 + exponent1 + exponent2 + np.log(fpt_z) - np.log(4*np.pi)\n        else:\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        x0 = threshold * np.cos(theta[i, 0])\n                        x1 = threshold * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = threshold * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'linear':\n                        x0 = (threshold - decay * (tt[i]-eps)) * np.cos(theta[i, 0])\n                        x1 = (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'exponential':\n                        x0 = (threshold * np.exp(-decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 = (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        x0 = (threshold / (1 + decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 = (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    elif self.threshold_dynamic == 'custom':\n                        x0 = threshold_function(tt[i]-eps) * np.cos(theta[i, 0])\n                        x1 = threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.cos(theta[i, 1]) \n                        x2 = threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.sin(theta[i, 1])\n                    fixed = 1/(np.sqrt(s_v2 * (tt[i] - eps) + 1))\n                    exponent0 = -0.5*drift_vec[i, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[i, 0])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent1 = -0.5*drift_vec[i, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[i, 1])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent2 = -0.5*drift_vec[i, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[i, 2])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n\n                    integrand = fixed**3 * np.exp(exponent0 + exponent1 + exponent2) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                    density = 1/(4*np.pi) * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    log_density[rt - ndt &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.Models.Spherical.SphericalDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate data from the Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>array - like</code> <p>Drift vector; a three-dimensional array</p> required <code>ndt</code> <code>float</code> <p>Non-decision time; a positive floating number</p> required <code>threshold</code> <code>float</code> <p>Decision threshold; a positive floating number (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>Decay rate of the collapsing boundary (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>Time step for the simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>Number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/Spherical.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate data from the Spherical Diffusion Model\n\n    Parameters\n    ----------\n    drift_vec : array-like\n        Drift vector; a three-dimensional array\n    ndt : float\n        Non-decision time; a positive floating number\n    threshold : float\n        Decision threshold; a positive floating number (default is 1)\n    decay : float, optional\n        Decay rate of the collapsing boundary (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        Time step for the simulation (default is 0.001)\n    n_sample : int, optional\n        Number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''\n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample, 2))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 3))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_SDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n], \n                                                     threshold_dynamic=self.threshold_dynamic, \n                                                     decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_custom_threshold_SDM_trial(threshold_function,\n                                                                      drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                      s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response1', 'response2'])\n</code></pre>"},{"location":"api/#hyper-spherical-diffusion-models","title":"Hyper-spherical diffusion models","text":""},{"location":"api/#CRDDM.Models.HyperSpherical.HyperSphericalDiffusionModel","title":"<code>HyperSphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Hyper-Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>threshold_dynamic</code> <code>str</code> <p>The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'</p> <code>'fixed'</code> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    '''\n    Parameters\n    ----------\n    threshold_dynamic : str, optional\n        The type of threshold collapse ('fixed', 'linear', 'exponential', 'hyperbolic', or 'custom'), default is 'fixed'\n    '''\n    self.name = 'Hyper-Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"api/#CRDDM.Models.HyperSpherical.HyperSphericalDiffusionModel.joint_lpdf","title":"<code>joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1)</code>","text":"<p>Compute the joint log-probability density function of response time and choice angles</p> <p>Parameters:</p> Name Type Description Default <code>rt</code> <code>(array - like, shape(n_samples))</code> <p>The response times</p> required <code>theta</code> <code>(array - like, shape(n_samples, 3))</code> <p>The choice angles in spherical coordinates (theta1, theta2, theta3)</p> required <code>drift_vec</code> <code>(array - like, shape(4) or (n_samples, 4))</code> <p>The drift rates in each dimension</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> required <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>dt_threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the derivative of the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <p>Returns:</p> Name Type Description <code>log_density</code> <code>(array - like, shape(n_samples))</code> <p>The joint log-probability density of response time and choice angles</p> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def joint_lpdf(self, rt, theta, drift_vec, ndt, threshold, decay=0, threshold_function=None, dt_threshold_function=None, s_v=0, s_t=0, sigma=1):\n    '''\n    Compute the joint log-probability density function of response time and choice angles\n\n    Parameters\n    ----------\n    rt : array-like, shape (n_samples,)\n        The response times\n    theta : array-like, shape (n_samples, 3)\n        The choice angles in spherical coordinates (theta1, theta2, theta3)\n    drift_vec : array-like, shape (4,) or (n_samples, 4)\n        The drift rates in each dimension\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    dt_threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the derivative of the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n\n    Returns\n    -------\n    log_density : array-like, shape (n_samples,)\n        The joint log-probability density of response time and choice angles\n    '''\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((rt.shape[0], 4))\n\n    if drift_vec.shape[1] != 4 or drift_vec.ndim != 2:\n        raise ValueError(\"drift_vec must have shape (4,) or (n_samples, 4)\")\n\n    tt = np.maximum(rt - ndt, 0)\n\n    # first-passage time density of zero drift process\n    if self.threshold_dynamic == 'fixed':\n        a = threshold\n        s0 = 0.002\n        s1 = 0.02\n        if s_t == 0:\n            s = tt/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1)\n            fpt_lt = hsdm_long_t_fpt_z(tt, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * hsdm_short_t_fpt_z(tt/threshold**2, 0.1**8/threshold**2)\n        else:\n            T = np.arange(0, tt.max()+0.05, 0.05)\n            s = T/threshold**2\n            w = np.minimum(np.maximum((s - s0) / (s1 - s0), 0), 1) \n            fpt_lt = hsdm_long_t_fpt_z(T, threshold, sigma=sigma)\n            fpt_st = 1/threshold**2 * hsdm_short_t_fpt_z(T/threshold**2, 0.1**8/threshold**2)\n        fpt_z =  (1 - w) * fpt_st + w * fpt_lt\n    elif self.threshold_dynamic == 'linear':\n        a = threshold - decay*tt\n        T_max = min(rt.max(), threshold/decay)\n        g_z, T = ie_fpt_linear(threshold, decay, 4, 0.000001, dt=0.02, T_max=T_max)\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'exponential':\n        a = threshold * np.exp(-decay*tt)\n        g_z, T = ie_fpt_exponential(threshold, decay, 4, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'hyperbolic':\n        a = threshold / (1 + decay*tt)\n        g_z, T = ie_fpt_hyperbolic(threshold, decay, 4, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n    elif self.threshold_dynamic == 'custom':\n        threshold_function2 = lambda t: threshold_function(t)**2\n        dt_threshold_function2 = lambda t: 2 * dt_threshold_function(t) * threshold_function(t)\n        a = threshold_function(tt)\n        g_z, T = ie_fpt_custom(threshold_function2, dt_threshold_function2, 4, 0.000001, dt=0.02, T_max=rt.max())\n        fpt_z = np.interp(tt, T, g_z)\n\n    fpt_z = np.maximum(fpt_z, 0.1**14)\n\n    # Girsanov:\n    if s_v == 0:\n        # No drift variability\n        mu_dot_x0 = drift_vec[:, 0]*np.cos(theta[:, 0])\n        mu_dot_x1 = drift_vec[:, 1]*np.sin(theta[:, 0])*np.cos(theta[:, 1]) \n        mu_dot_x2 = drift_vec[:, 2]*np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.cos(theta[:, 2])\n        mu_dot_x3 = drift_vec[:, 3]*np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.sin(theta[:, 2])\n        if s_t == 0:\n            # No non-decision time variability\n            term1 = a * (mu_dot_x0 + mu_dot_x1 + mu_dot_x2 + mu_dot_x3) / sigma**2\n            term2 = 0.5 * (drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2 + drift_vec[:, 3]**2) * tt\n            log_density = term1 - term2 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            # With non-decision time variability\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            norm2_drift = drift_vec[:, 0]**2 + drift_vec[:, 1]**2 + drift_vec[:, 2]**2 + drift_vec[:, 3]**2\n            mu_dot_x = (mu_dot_x0 + mu_dot_x1 + mu_dot_x2 + mu_dot_x3) / sigma**2\n\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        integrand = np.exp(- 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * np.exp(threshold * mu_dot_x[i]) * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'linear':\n                        integrand = np.exp((threshold - decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'exponential':\n                        integrand = np.exp(threshold*np.exp(-decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        integrand = np.exp(threshold/(1  + decay * (tt[i] - eps)) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n                    elif self.threshold_dynamic == 'custom':\n                        integrand = np.exp(threshold_function(tt[i] - eps) * mu_dot_x[i] - 0.5 * norm2_drift[i] * (tt[i] - eps)) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                        density = 0.5/np.pi * trapz_1d(integrand, eps)\n\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n    else:\n        # With drift variability\n        if s_t == 0:\n            s_v2 = s_v**2\n            x0 =  a * np.cos(theta[:, 0])\n            x1 =  a * np.sin(theta[:, 0])*np.cos(theta[:, 1])\n            x2 =  a * np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.cos(theta[:, 2])\n            x3 =  a * np.sin(theta[:, 0])*np.sin(theta[:, 1])*np.sin(theta[:, 2])\n            fixed = 1/(np.sqrt(s_v2 * tt + 1))\n            exponent0 = -0.5*drift_vec[:, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[:, 0])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent1 = -0.5*drift_vec[:, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[:, 1])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent2 = -0.5*drift_vec[:, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[:, 2])**2 / (s_v2 * (s_v2 * tt + 1))\n            exponent3 = -0.5*drift_vec[:, 3]**2/s_v2 + 0.5*(x3 * s_v2 + drift_vec[:, 3])**2 / (s_v2 * (s_v2 * tt + 1))\n\n            # the joint density of choice and RT for the full process\n            log_density = 4*np.log(fixed) + exponent0 + exponent1 + exponent2 + exponent3 + np.log(fpt_z) - np.log(2*np.pi)\n        else:\n            log_density = np.log(0.1**14) * np.ones(rt.shape[0])\n            eps = np.linspace(0, s_t, max(2, int(s_t//0.02)))\n            s_v2 = s_v**2\n            for i in range(rt.shape[0]):\n                if tt[i] - s_t &gt; 0:\n                    if self.threshold_dynamic == 'fixed':\n                        x0 =  threshold * np.cos(theta[i, 0])\n                        x1 =  threshold * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  threshold * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  threshold * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'linear':\n                        x0 =  (threshold - decay * (tt[i]-eps)) * np.cos(theta[i, 0])\n                        x1 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  (threshold - decay * (tt[i]-eps)) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'exponential':\n                        x0 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  (threshold * np.exp(-decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'hyperbolic':\n                        x0 =  (threshold / (1 + decay * (tt[i]-eps))) * np.cos(theta[i, 0])\n                        x1 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  (threshold / (1 + decay * (tt[i]-eps))) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    elif self.threshold_dynamic == 'custom':\n                        x0 =  threshold_function(tt[i]-eps) * np.cos(theta[i, 0])\n                        x1 =  threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.cos(theta[i, 1])\n                        x2 =  threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.cos(theta[i, 2])\n                        x3 =  threshold_function(tt[i]-eps) * np.sin(theta[i, 0])*np.sin(theta[i, 1])*np.sin(theta[i, 2])\n                    fixed = 1/(np.sqrt(s_v2 * (tt[i] - eps) + 1))\n                    exponent0 = -0.5*drift_vec[i, 0]**2/s_v2 + 0.5*(x0 * s_v2 + drift_vec[i, 0])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent1 = -0.5*drift_vec[i, 1]**2/s_v2 + 0.5*(x1 * s_v2 + drift_vec[i, 1])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent2 = -0.5*drift_vec[i, 2]**2/s_v2 + 0.5*(x2 * s_v2 + drift_vec[i, 2])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n                    exponent3 = -0.5*drift_vec[i, 3]**2/s_v2 + 0.5*(x3 * s_v2 + drift_vec[i, 3])**2 / (s_v2 * (s_v2 * (tt[i] - eps) + 1))\n\n                    integrand = fixed**4 * np.exp(exponent0 + exponent1 + exponent2 + exponent3) * np.interp(tt[i]-eps, T, fpt_z)/s_t\n                    density = 1/(2*np.pi) * trapz_1d(integrand, eps)\n                    if density &gt; 0.1**14:\n                        log_density[i] = np.log(density)\n\n    log_density[rt - ndt &lt;= 0] = np.log(0.1**14)\n    log_density = np.maximum(log_density, np.log(0.1**14))\n\n    return log_density\n</code></pre>"},{"location":"api/#CRDDM.Models.HyperSpherical.HyperSphericalDiffusionModel.simulate","title":"<code>simulate(drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1)</code>","text":"<p>Simulate data from the Hyper-Spherical Diffusion Model</p> <p>Parameters:</p> Name Type Description Default <code>drift_vec</code> <code>(array - like, shape(4))</code> <p>The drift rates in each dimension</p> required <code>ndt</code> <code>float</code> <p>The non-decision time</p> required <code>threshold</code> <code>float</code> <p>The decision threshold (default is 1)</p> <code>1</code> <code>decay</code> <code>float</code> <p>The threshold decay rate (default is 0)</p> <code>0</code> <code>threshold_function</code> <code>callable, if threshold_dynamic is 'custom'</code> <p>A function that takes time t and returns the threshold at time t</p> <code>None</code> <code>s_v</code> <code>float</code> <p>The standard deviation of drift variability (default is 0)</p> <code>0</code> <code>s_t</code> <code>float</code> <p>The standard deviation of non-decision time variability (default is 0)</p> <code>0</code> <code>sigma</code> <code>float</code> <p>The diffusion coefficient (default is 1)</p> <code>1</code> <code>dt</code> <code>float</code> <p>Time step for the simulation (default is 0.001)</p> <code>0.001</code> <code>n_sample</code> <code>int</code> <p>Number of samples to simulate (default is 1)</p> <code>1</code> <p>Returns:</p> Type Description <code>DataFrame</code> <p>A DataFrame containing simulated response times and choice angles</p> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def simulate(self, drift_vec, ndt, threshold=1, decay=0, threshold_function=None, s_v=0, s_t=0, sigma=1, dt=0.001, n_sample=1):\n    '''\n    Simulate data from the Hyper-Spherical Diffusion Model\n\n    Parameters\n    ----------\n    drift_vec : array-like, shape (4,)\n        The drift rates in each dimension\n    ndt : float\n        The non-decision time\n    threshold : float\n        The decision threshold (default is 1)\n    decay : float, optional\n        The threshold decay rate (default is 0)\n    threshold_function : callable, if threshold_dynamic is 'custom'\n        A function that takes time t and returns the threshold at time t\n    s_v : float, optional\n        The standard deviation of drift variability (default is 0)\n    s_t : float, optional\n        The standard deviation of non-decision time variability (default is 0)\n    sigma : float, optional\n        The diffusion coefficient (default is 1)\n    dt : float, optional\n        Time step for the simulation (default is 0.001)\n    n_sample : int, optional\n        Number of samples to simulate (default is 1)\n\n    Returns\n    -------\n    pd.DataFrame\n        A DataFrame containing simulated response times and choice angles\n    '''\n    RT = np.empty((n_sample,))\n    Choice = np.empty((n_sample, 3))\n\n    if drift_vec.ndim == 1:\n        drift_vec = drift_vec * np.ones((n_sample, 4))\n    elif drift_vec.shape[0] != n_sample:\n        raise ValueError(\"Number of rows in drift_vec must be equal to n_sample\")\n\n    if isinstance(ndt, (float, np.floating)) or isinstance(ndt, (int, np.integer)):\n        ndt = np.full((n_sample,), ndt)\n    elif len(ndt) != n_sample:\n        raise ValueError(\"Length of ndt must be equal to n_sample\")\n\n    if isinstance(threshold, (float, np.floating)) or isinstance(threshold, (int, np.integer)):\n        threshold = np.full((n_sample,), threshold)\n    elif len(threshold) != n_sample:\n        raise ValueError(\"Length of threshold must be equal to n_sample\")\n\n    if isinstance(decay, (float, np.floating)) or isinstance(decay, (int, np.integer)):\n        decay = np.full((n_sample,), decay)\n    elif len(decay) != n_sample:\n        raise ValueError(\"Length of decay must be equal to n_sample\")\n\n    if threshold_function is None and self.threshold_dynamic == 'custom':\n        raise ValueError(\"threshold_function must be provided when threshold_dynamic is 'custom'\")\n\n    if threshold_function is not None and self.threshold_dynamic != 'custom':\n        raise ValueError(\"threshold_function should be None when threshold_dynamic is not 'custom'\")\n\n    if s_v &lt; 0:\n        raise ValueError(\"s_v must be non-negative\")\n    if s_t &lt; 0:\n        raise ValueError(\"s_t must be non-negative\")\n\n    if self.threshold_dynamic != 'custom':\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_HSDM_trial(threshold[n], drift_vec[n, :].astype(np.float64), ndt[n],\n                                                      threshold_dynamic=self.threshold_dynamic, \n                                                      decay=decay[n], s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    else:\n        for n in range(n_sample):\n            RT[n], Choice[n, :] = simulate_custom_threshold_HSDM_trial(threshold_function,\n                                                                       drift_vec[n, :].astype(np.float64), ndt[n], \n                                                                       s_v=s_v, s_t=s_t, sigma=sigma, dt=dt)\n    return pd.DataFrame(np.c_[RT, Choice], columns=['rt', 'response1', 'response2', 'response3'])\n</code></pre>"},{"location":"api/#CRDDM.Models.HyperSpherical.ProjectedHyperSphericalDiffusionModel","title":"<code>ProjectedHyperSphericalDiffusionModel(threshold_dynamic='fixed')</code>","text":"<p>Projected Hyper-Spherical Diffusion Model</p> Source code in <code>CRDDM/Models/HyperSpherical.py</code> <pre><code>def __init__(self, threshold_dynamic='fixed'):\n    self.name = 'Projected Hyper-Spherical Diffusion Model'\n\n    if threshold_dynamic in ['fixed', 'linear', 'exponential', 'hyperbolic', 'custom']:\n        self.threshold_dynamic = threshold_dynamic\n    else:\n        raise ValueError(\"\\'threshold_dynamic\\' must be one of \\'fixed\\', \\'linear\\', \\'exponential\\', \\'hyperbolic\\', or \\'custom\\'. However, got \\'{}\\'\".format(threshold_dynamic))\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#install-via-pip","title":"Install via <code>pip</code>","text":"<p>The package can be installed via pip: <pre><code>pip istall crddm\n</code></pre></p>"},{"location":"installation/#install-from-source","title":"Install from source","text":"<p>Alternatively, clone or download the source code and install locally: <pre><code>python -m setup.py\n</code></pre></p>"},{"location":"installation/#dependencies","title":"Dependencies","text":"<p>CRDDM requires the following Python packages:</p> <ul> <li><code>numpy</code></li> <li><code>scipy</code></li> <li><code>pandas</code></li> <li><code>numba</code></li> </ul> <p>All dependencies are installed automatically when using <code>pip</code>.</p>"},{"location":"installation/#conda-environment-suggested","title":"Conda environment (suggested)","text":"<p>If you have Andaconda or miniconda installed and you would like to create a separate environment:</p> <pre><code>conda create --n crddm python=3 numpy scipy pandas numba\nconda activate crddm\npip install crddm\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/","title":"Collapsing Threshold Models: A Parameter Recovery Simulation","text":"<p>This tutorial illustrates how to use CRDDM to fit collapsing threshold diffusion models and to fit a joint model on observed data from multiple sources (e.g., behavior and neural signals). </p> <p>This tutorial contains a simple parameter recovery study using Circular Diffusion Model (CDM) with a linear collapsing decision threshold. We considered two setups for parameter recovery:</p> <ol> <li> <p>Uninformed collapsing-threshold model: fit the model using only choice/RT data.</p> </li> <li> <p>NDT-informed collapsing-threshold model (joint modeling): fit the model using choice/RT data and    additional measurements that inform the non-decision time (NDT) distribution.</p> </li> </ol>"},{"location":"tutorials/collapsing_threshold_models/#import-required-packages","title":"Import required packages","text":"<pre><code>import numpy as np\nimport pandas as pd\nfrom tqdm import tqdm\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom scipy.optimize import differential_evolution\n\nfrom CRDDM.Models.Circular import CircularDiffusionModel as CDM\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/#1-uninformed-collapsing-threshold-diffusion-models","title":"1. Uninformed collapsing threshold diffusion models:","text":"<p>In the first setup, we simulate data from a CDM with a linear collapsing threshold and then recover:</p> <ul> <li><code>threshold</code>: initial decision threshold,</li> <li><code>decay</code>: collapse rate (linear),</li> <li><code>ndt</code>: non-decision time,</li> <li><code>mu_x, mu_y</code>: drift vector components.</li> </ul>"},{"location":"tutorials/collapsing_threshold_models/#11-negative-log-likelihood","title":"1.1 Negative log-likelihood","text":"<pre><code>def negative_log_likelihood(params, rt, theta, model):\n    threshold = params[0]            # initial decision threshold\n    decay = params[1]                # decay rate of threshold\n    ndt = params[2]                  # non-decision time\n    drift_vec = np.array([params[3], params[4]])  # drift vector\n\n    logpdf = model.joint_lpdf(rt, theta, drift_vec, ndt, threshold, decay=decay)\n\n    return -np.sum(logpdf)\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/#12-simulation-setup","title":"1.2 Simulation setup","text":"<pre><code>n_trials = 500\n\nrecovery_df = {\n    \"threshold_true\": [], \"threshold_estimate\": [],\n    \"decay_true\": [], \"decay_estimate\": [],\n    \"ndt_true\": [], \"ndt_estimate\": [],\n    \"mu_x_true\": [], \"mu_x_estimate\": [],\n    \"mu_y_true\": [], \"mu_y_estimate\": []\n}\n\n# Bounds for estimation\nmin_threshold, max_threshold = 2, 5\nmin_decay, max_decay = 0.05, 2\nmin_ndt, max_ndt = 0, 1.5\nmin_mu, max_mu = -5, 5\n\nprms_bounds = [\n    (min_threshold, max_threshold),\n    (min_decay, max_decay),\n    (min_ndt, max_ndt),\n    (min_mu, max_mu),\n    (min_mu, max_mu),\n]\n\nmodel = CDM(threshold_dynamic='exponential')\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/#13-simulation-and-estimation-loop","title":"1.3 Simulation and estimation loop","text":"<pre><code>for n in tqdm(range(20)):\n    # Random generative parameters\n    threshold = np.random.uniform(min_threshold, max_threshold)\n    decay = np.random.uniform(min_decay, max_decay)\n    mu_x = np.random.uniform(min_mu, max_mu)\n    mu_y = np.random.uniform(min_mu, max_mu)\n    drift_vector = np.array([mu_x, mu_y])\n    ndt = np.random.uniform(min_ndt, max_ndt)\n\n    # Simulating data with random generated parameters\n    sim_df = model.simulate(\n        drift_vector,\n        ndt,\n        threshold,\n        decay=decay,\n        n_sample=n_trials,\n    )\n\n    # Estimate parameters\n    min_ans = differential_evolution(\n        negative_log_likelihood,\n        bounds=prms_bounds,\n        args=(sim_df[\"rt\"].values, sim_df[\"response\"].values, model),\n    )\n\n    # Store true parameters\n    recovery_df[\"threshold_true\"].append(threshold)\n    recovery_df[\"decay_true\"].append(decay)\n    recovery_df[\"ndt_true\"].append(ndt)\n    recovery_df[\"mu_x_true\"].append(mu_x)\n    recovery_df[\"mu_y_true\"].append(mu_y)\n\n    # Store estimates\n    recovery_df[\"threshold_estimate\"].append(min_ans.x[0])\n    recovery_df[\"decay_estimate\"].append(min_ans.x[1])\n    recovery_df[\"ndt_estimate\"].append(min_ans.x[2])\n    recovery_df[\"mu_x_estimate\"].append(min_ans.x[3])\n    recovery_df[\"mu_y_estimate\"].append(min_ans.x[4])\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [03:01&lt;00:00,  9.07s/it]\n</code></pre> <pre><code>plt.figure(figsize=(13, 3), layout=\"constrained\")\n\nplt.subplot(141)\nplt.plot(np.arange(2, 6, 0.01), np.arange(2, 6, 0.01), c=\"red\")\nsns.scatterplot(x=\"threshold_true\", y=\"threshold_estimate\", data=recovery_df, color=\"black\", alpha=0.3)\nplt.xlabel(\"threshold true\")\nplt.ylabel(\"threshold estimate\")\n\nplt.subplot(142)\nplt.plot(np.arange(0, 2, 0.01), np.arange(0, 2, 0.01), c=\"red\")\nsns.scatterplot(x=\"decay_true\", y=\"decay_estimate\", data=recovery_df, color=\"black\", alpha=0.3)\nplt.xlabel(\"decay true\")\nplt.ylabel(\"decay estimate\")\n\nplt.subplot(143)\nplt.plot(np.arange(0, 2, 0.01), np.arange(0, 2, 0.01), c=\"red\")\nsns.scatterplot(x=\"ndt_true\", y=\"ndt_estimate\", data=recovery_df, color=\"black\", alpha=0.3)\nplt.xlabel(\"ndt true\")\nplt.ylabel(\"ndt estimate\")\n\nplt.subplot(144)\nplt.plot(np.arange(-6, 6, 0.01), np.arange(-6, 6, 0.01), c=\"red\")\nsns.scatterplot(x=\"mu_x_true\", y=\"mu_x_estimate\", data=recovery_df, color=\"black\", alpha=0.3)\nsns.scatterplot(x=\"mu_y_true\", y=\"mu_y_estimate\", data=recovery_df, color=\"black\", alpha=0.3)\nplt.xlabel(r\"$\\mu_i$ true\")\nplt.ylabel(r\"$\\mu_i$ estimate\")\nplt.show()\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/#2-ndt-informed-collapsing-threshold-diffusion-models-joint-modeling","title":"2. NDT-informed collapsing threshold diffusion models (joint modeling):","text":"<p>In many experiments, additional measurements can constrain the NDT distribution (e.g., encoding time, motor time, or other process-pure measures). Here we demonstrate a simple joint model where:</p> <ul> <li>the diffusion model explains choice/RT data,</li> <li>a Gaussian measurement model explains observed <code>ndt_measurements</code>.</li> </ul> <p>We recover:</p> <ul> <li><code>threshold</code>, <code>decay</code>,</li> <li><code>mean_ndt</code> and <code>sd_ndt</code>,</li> <li><code>mu_x, mu_y</code>.</li> </ul>"},{"location":"tutorials/collapsing_threshold_models/#21-negative-joint-log-likelihood","title":"2.1 Negative joint log-likelihood","text":"<pre><code>def negative_log_likelihood_ndt_informed(params, rt, theta, ndt_mesurements, model):\n    threshold =  params[0]    # initial decision threshold\n    decay = params [1]        # decay rate of threshold\n\n    # mean of non-decision time measurements (shared across observation and diffusion model)\n    mean_ndt = params[2] \n    sd_ndt = params[3] # SD of non-decision time measurements\n    drift_vec = np.array([params[4], params[5]]) # drift vector\n\n    ndt_logpdf = -0.5 * (ndt_mesurements - mean_ndt)**2/sd_ndt**2 - 0.5 * np.log(2*np.pi*sd_ndt**2)\n    choice_logpdf = model.joint_lpdf(rt, theta, drift_vec, mean_ndt, threshold, decay=decay)\n\n    return -np.sum(choice_logpdf) - np.sum(ndt_logpdf)\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/#22-simulation-setup","title":"2.2 Simulation setup","text":"<pre><code>n_trials = 500\n\nrecovery_df = {\n    \"threshold_true\": [], \"threshold_estimate\": [],\n    \"decay_true\": [], \"decay_estimate\": [],\n    \"mean_ndt_true\": [], \"mean_ndt_estimate\": [],\n    \"sd_ndt_true\": [], \"sd_ndt_estimate\": [],\n    \"mu_x_true\": [], \"mu_x_estimate\": [],\n    \"mu_y_true\": [], \"mu_y_estimate\": []\n}\n\nmin_threshold, max_threshold = 2, 5\nmin_decay, max_decay = 0.05, 2\nmin_mean_ndt, max_mean_ndt = 0.05, 1.5\nmin_sd_ndt, max_sd_ndt = 0.01, 0.5\nmin_mu, max_mu = -5, 5\n\nprms_bounds = [\n    (min_threshold, max_threshold),\n    (min_decay, max_decay),\n    (min_mean_ndt, max_mean_ndt),   \n    (min_sd_ndt, max_sd_ndt),\n    (min_mu, max_mu),\n    (min_mu, max_mu),\n]\n\nmodel = CDM(threshold_dynamic='exponential')\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/#23-simulation-and-estimation-loop","title":"2.3 Simulation and estimation loop","text":"<pre><code>for n in tqdm(range(20)):    \n    # generating some random parameters\n    threshold = np.random.uniform(min_threshold, max_threshold)\n    decay = np.random.uniform(min_decay, max_decay)\n    mu_x = np.random.uniform(min_mu, max_mu)\n    mu_y = np.random.uniform(min_mu, max_mu)\n    drift_vector = np.array([mu_x, mu_y])\n\n    mean_ndt = np.random.uniform(0.05, max_ndt)\n    sd_ndt = np.random.uniform(mean_ndt/5, mean_ndt/3)\n    ndt_mesurements = mean_ndt + sd_ndt*np.random.randn(n_trials)\n\n    sim_df = model.simulate(drift_vector, \n                            mean_ndt,\n                            threshold, \n                            decay=decay,\n                            n_sample=n_trials)\n\n    # Estimating the paramters for the simulated data\n    min_ans = differential_evolution(negative_log_likelihood_ndt_informed, \n                                     args=(sim_df['rt'].values, \n                                           sim_df['response'].values,\n                                           ndt_mesurements,\n                                           model), \n                                     bounds=prms_bounds)\n\n\n    # Storing the true generating parameters\n    recovery_df['threshold_true'].append(threshold)\n    recovery_df['decay_true'].append(decay)\n    recovery_df['mean_ndt_true'].append(mean_ndt)\n    recovery_df['sd_ndt_true'].append(sd_ndt)\n    recovery_df['mu_x_true'].append(mu_x)\n    recovery_df['mu_y_true'].append(mu_y)\n\n    # Stroing the estimated parameters\n    recovery_df['threshold_estimate'].append(min_ans.x[0])\n    recovery_df['decay_estimate'].append(min_ans.x[1])\n    recovery_df['mean_ndt_estimate'].append(min_ans.x[2])\n    recovery_df['sd_ndt_estimate'].append(min_ans.x[3])\n    recovery_df['mu_x_estimate'].append(min_ans.x[4])\n    recovery_df['mu_y_estimate'].append(min_ans.x[5])\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 20/20 [03:49&lt;00:00, 11.45s/it]\n</code></pre> <pre><code>plt.figure(figsize=(15, 3), layout='constrained')\n\nplt.subplot(151)\nplt.plot(np.arange(2, 6, 0.01), np.arange(2, 6, 0.01), c='red')\nsns.scatterplot(x='threshold_true', y='threshold_estimate', data=recovery_df, color='black', alpha=0.3);\nplt.xlabel(r'threshold true')\nplt.ylabel(r'threshold estimate')\n\nplt.subplot(152)\nplt.plot(np.arange(0, 2, 0.01), np.arange(0, 2, 0.01), c='red')\nsns.scatterplot(x='decay_true', y='decay_estimate', data=recovery_df, color='black', alpha=0.3);\nplt.xlabel(r'decay true')\nplt.ylabel(r'decay estimate')\n\nplt.subplot(153)\nplt.plot(np.arange(0, 2, 0.01), np.arange(0, 2, 0.01), c='red')\nsns.scatterplot(x='mean_ndt_true', y='mean_ndt_estimate', data=recovery_df, color='black', alpha=0.3);\nplt.xlabel(r'mean_ndt true')\nplt.ylabel(r'mean_ndt estimate')\n\nplt.subplot(154)\nplt.plot(np.arange(0, 0.5, 0.01), np.arange(0, 0.5, 0.01), c='red')\nsns.scatterplot(x='sd_ndt_true', y='sd_ndt_estimate', data=recovery_df, color='black', alpha=0.3);\nplt.xlabel(r'sd_ndt true')\nplt.ylabel(r'sd_ndt estimate')\n\nplt.subplot(155)\nplt.plot(np.arange(-6, 6, 0.01), np.arange(-6, 6, 0.01), c='red')\nsns.scatterplot(x='mu_x_true', y='mu_x_estimate', data=recovery_df, color='black', alpha=0.3);\nsns.scatterplot(x='mu_y_true', y='mu_y_estimate', data=recovery_df, color='black', alpha=0.3);\nplt.xlabel(r'$\\mu_i$ true')\nplt.ylabel(r'$\\mu_i$ estimate');\n</code></pre>"},{"location":"tutorials/collapsing_threshold_models/#notes","title":"Notes","text":"<p>Always check parameter recovery</p> <p>When introducing a new mapping function, mixture model, or joint model, always perform a parameter recovery study before applying the model to empirical data.</p> <p>Parameter recovery helps ensure that: - the likelihood function is implemented correctly, - parameters are identifiable given the data and design, - different model components (e.g., guessing vs. diffusion, threshold vs. NDT) are not confounded.</p> <p>Skipping this step can lead to misleading parameter estimates and incorrect theoretical conclusions.</p>"},{"location":"tutorials/collapsing_threshold_models/#references","title":"References","text":"<ul> <li> <p>Hadian Rasanan, A. H., Schumacher, L., Nunez, M. D., Weindel, G., &amp; Rieskamp, J. (2025). Non-decision time-informed collapsing threshold diffusion model: A joint modeling framework with identifiable time-dependent parameters. bioRxiv, 2025-10. https://doi.org/10.1101/2025.10.30.685574</p> </li> <li> <p>Hadian Rasanan, A. H., Evans, N. J., Amani Rad, J., &amp; Rieskamp, J. (2025). Parameter estimation of hyper-spherical diffusion models with a time-dependent threshold: An integral equation method. Behavior Research Methods, 57(10), 283. https://doi.org/10.3758/s13428-025-02810-3</p> </li> </ul>"},{"location":"tutorials/custom_mapping_function/","title":"Custom Mapping Function: Drift Angle Modulation Using Utility Theory","text":"<p>This tutorial demonstrates how to define a custom mapping function that maps trial-wise stimuli to trial-wise model parameters. The example uses a pricing paradigm in which, on each trial, a participant evaluates a lottery that pays an outcome <code>x</code> with probability <code>p</code> (otherwise \\(0\\)) and reports a willingness-to-pay (WTP) on a bounded scale from \\(\\$ 0\\) to \\(\\$ 20\\).</p> <p>To model this scenario, we use a Projected Spherical Diffusion Model (PSDM) and combine it with a simple utility function so that the drift direction (angle) varies by trial as a function of the subjective utility of the presented lottery.</p>"},{"location":"tutorials/custom_mapping_function/#1-import-required-packages","title":"1. Import required packages","text":"<pre><code>import numpy as np\n\nfrom scipy.optimize import differential_evolution\nfrom CRDDM.Models.Spherical import ProjectedSphericalDiffusionModel as PSDM\n</code></pre> <p>(Optional, for visualization)</p> <pre><code>import matplotlib.pyplot as plt\nimport seaborn as sns\n</code></pre>"},{"location":"tutorials/custom_mapping_function/#2-create-a-projected-spherical-diffusion-model","title":"2. Create a projected spherical diffusion model","text":"<p>This model is useful for bounded response scales, which often are employed in the estimation or valuation tasks. </p> <pre><code>model = PSDM(threshold_dynamic=\"fixed\")\n</code></pre>"},{"location":"tutorials/custom_mapping_function/#3-generate-trial-wise-lotteries","title":"3. Generate trial-wise lotteries","text":"<p>In each trial, a lottery with probability of winning \\(p \\in [0.1, 0.9]\\) and outcome \\(x \\in [10, 20]\\) is presented.</p> <pre><code>n_sample = 500\nprobability = np.random.uniform(0.1, 0.9, n_sample)\noutcome = np.random.uniform(10, 20, n_sample)\n</code></pre>"},{"location":"tutorials/custom_mapping_function/#4-define-the-custom-mapping-and-simulate-data","title":"4. Define the custom mapping and simulate data","text":""},{"location":"tutorials/custom_mapping_function/#utility-model","title":"Utility model","text":"<p>We define subjective utility as:</p> \\[u = p \\cdot x^{\\alpha},\\] <p>where \\(\\alpha\\) is a utility power parameter.</p>"},{"location":"tutorials/custom_mapping_function/#mapping-utility-to-drift-angle","title":"Mapping utility to drift angle","text":"<p>We map utility to a drift angle \\(\\theta_{\\mu}\\) over the response range:</p> \\[ \\theta_{\\mu} = \\frac{u}{\\text{max response range}} \\times \\pi = \\frac{u}{20} \\times \\pi. \\] <p>This mapping function is introduced by Kvam &amp; Busemeyer (2020)</p>"},{"location":"tutorials/custom_mapping_function/#drift-vector-trial-wise","title":"Drift vector (trial-wise)","text":"<p>Given a drift magnitude \\(\\|\\mu\\|\\), the trial-wise drift vectors are:</p> \\[ \\mu = \\|\\mu\\| \\times [\\cos(\\theta_{\\mu}),\\ \\sin(\\theta_{\\mu})]. \\]"},{"location":"tutorials/custom_mapping_function/#simulate","title":"Simulate","text":"<pre><code># Ground-truth parameters\nthreshold = 3.0\nutility_power = 0.5\ndrift_magnitude = 2.0\nndt = 0.25\nmax_response_range = 20.0\n\n# Trial-wise subjective utility\nsubjective_utility = probability * outcome**utility_power\n\n# Custom mapping: utility -&gt; drift angle\ndrift_angles = subjective_utility / max_response_range * np.pi\n\n# Trial-wise drift vectors\ndrift_vectors = drift_magnitude * np.c_[np.cos(drift_angles), \n                                        np.sin(drift_angles)]\n\n# Simulate responses and RTs\nsim_data = model.simulate(\n    drift_vectors,\n    ndt,\n    threshold=threshold,\n    n_sample=n_sample,\n)\n\nsim_data.head()\n</code></pre> <p>The simulated dataset contains: - <code>rt</code>: response times - <code>response</code>: model responses on the model scale (radians). </p> <p>Note: For WTP on \\([0, 20]\\), you can convert via:  \\(\\text{WTP} = \\text{response}/\\pi \\times 20\\).</p>"},{"location":"tutorials/custom_mapping_function/#5-optional-visualize-simulated-data","title":"5. (Optional) Visualize simulated data","text":"<pre><code>plt.figure(figsize=(9, 4), layout=\"constrained\")\n\nplt.subplot(121)\nsns.histplot(sim_data[\"rt\"], stat=\"density\")\nplt.title(\"Response times\")\n\nplt.subplot(122)\nsns.histplot(sim_data[\"response\"] / np.pi * 20, stat=\"density\")\nplt.title(\"WTP (mapped from response)\")\n</code></pre>"},{"location":"tutorials/custom_mapping_function/#6-define-the-likelihood-with-the-custom-mapping","title":"6. Define the likelihood with the custom mapping","text":"<p>To estimate parameters, we define a negative log-likelihood. Critically, the custom mapping (probabilities and outcomes \u2192 drift angles \u2192 drift vectors) is recomputed inside the likelihood function.</p> <pre><code>def negative_log_likelihood(params, rt, theta, probability, outcome, model):\n    threshold = params[0]\n    ndt = params[1]\n    drift_magnitude = params[2]\n    utility_power = params[3]\n\n    # Trial-wise utility\n    subjective_utility = probability * outcome**utility_power\n\n    # Custom mapping: utility -&gt; drift angle (bounded scale [0, 20])\n    drift_angles = subjective_utility / 20.0 * np.pi\n\n    # Trial-wise drift vectors\n    drift_vectors = drift_magnitude * np.c_[np.cos(drift_angles), \n                                            np.sin(drift_angles)]\n\n    # Joint log-likelihood over RT and response\n    logpdf = model.joint_lpdf(rt, theta, drift_vectors, ndt, threshold)\n    return -np.sum(logpdf)\n</code></pre>"},{"location":"tutorials/custom_mapping_function/#7-estimate-parameters-using-differential-evolution","title":"7. Estimate parameters using differential evolution","text":"<pre><code>bounds = [\n    (0.05, 5.0),  # threshold\n    (0.0, 2.0),   # non-decision time\n    (0.0, 5.0),   # drift magnitude\n    (0.0, 1.0),   # utility power\n]\n\nparam_names = [\"threshold\", \"ndt\", \"drift_magnitude\", \"utility_power\"]\n\nresult = differential_evolution(\n    negative_log_likelihood,\n    bounds=bounds,\n    args=(\n        sim_data[\"rt\"].values,\n        sim_data[\"response\"].values,\n        probability,\n        outcome,\n        model,\n    ),\n)\n</code></pre>"},{"location":"tutorials/custom_mapping_function/#8-inspect-recovered-parameters","title":"8. Inspect recovered parameters","text":"<pre><code>for name, value in zip(param_names, result.x):\n    print(f\"{name}: {value:.3f}\")\n</code></pre> <p>If the model is identifiable for this configuration and the optimizer converges well, the recovered parameters should be close to the simulation values used above.</p>"},{"location":"tutorials/custom_mapping_function/#notes","title":"Notes","text":"<ul> <li>Custom mapping functions enable flexible model specification for stimulus dependent modulation of the models parameters.</li> <li>You can replace the utility model with any other mapping function, e.g. prospect theory, reference dependence, or regression-style mappings.</li> <li>The same pattern extends naturally to other CRDDM models and other parameters of the models.</li> <li>A parameter recovery study based on the task design and mapping function is required to ensure that the parameters are identifiable.</li> </ul>"},{"location":"tutorials/custom_mapping_function/#reference","title":"Reference","text":"<ul> <li>Kvam, P. D., &amp; Busemeyer, J. R. (2020). A distributional and dynamic theory of pricing and preference. Psychological Review, 127(6), 1053\u20131078. https://doi.org/10.1037/rev0000215</li> </ul>"},{"location":"tutorials/design_spesification/","title":"Design Specification: Condition-Specific Parameters (Speed\u2013Accuracy Tradeoff)","text":"<p>This tutorial demonstrates how to implement design specifications in CRDDM\u2014that is, how experimental manipulations are translated into condition-specific model parameters within a single likelihood function.</p> <p>In the example below (based on the accompanying notebook), we fit a Circular Diffusion Model (CDM) to data from an orientation judgment task reported in Kvam (2019). In this task, participants viewed a dynamic Gabor patch and reported the average orientation of the stimulus by clicking on a circular response scale:</p> <p></p> <p>The experimental design includes two orthogonal manipulations:</p> <ul> <li>a speed\u2013accuracy trade-off instruction (<code>isSpeed</code>),</li> <li>a stimulus difficulty manipulation (<code>jitter</code> \u2208 {15, 30, 45} degrees).</li> </ul> <p>To model these data, we specify a circular diffusion model with the following structure:</p> <ul> <li>the decision threshold is condition-specific, differing between speed and accuracy blocks;</li> <li>the drift magnitude varies across difficulty levels (indexed by jitter);</li> <li>the drift angle and non-decision time (NDT) are shared across all conditions.</li> </ul> <p>This parameterization allows the model to capture systematic changes in response caution and evidence quality induced by task instructions and stimulus difficulty, while maintaining a parsimonious representation of shared decision dynamics.</p>"},{"location":"tutorials/design_spesification/#1-import-required-packages","title":"1. Import required packages","text":"<pre><code>import numpy as np\nimport pandas as pd\n\nfrom tqdm import tqdm\n\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\nfrom scipy.optimize import differential_evolution\n\nfrom CRDDM.utility.datasets import load_kvam2019\nfrom CRDDM.Models.Circular import CircularDiffusionModel as CDM\n</code></pre>"},{"location":"tutorials/design_spesification/#2-load-the-dataset","title":"2. Load the dataset","text":"<pre><code>data = load_kvam2019()\n\ndata.head()\n</code></pre> Participant isSpeed jitter response deviation rt 100 0 45 1.9217 -0.5391 1.2595 100 0 30 1.7845 0.32968 0.86939 100 0 15 0.26625 -0.30658 0.8009 100 0 30 2.157 0.15855 1.0019 100 0 15 1.7277 0.0072374 2.364 <p>This dataset includes:</p> <ul> <li><code>Participant</code>: participant identifier,</li> <li><code>isSpeed</code>: instruction condition (1 = speed, 0 = accuracy),</li> <li><code>jitter</code>: stimulus difficulty (15, 30, 45 degrees),</li> <li><code>deviation</code>: signed angular response deviation (radians),</li> <li><code>rt</code>: response time (seconds).</li> </ul>"},{"location":"tutorials/design_spesification/#3-define-the-likelihood-with-design-specific-parameters","title":"3. Define the likelihood with design-specific parameters","text":"<p>The likelihood function below constructs trial-wise drift vectors based on the experimental design and routes trials to condition-specific thresholds depending on the instruction condition.</p>"},{"location":"tutorials/design_spesification/#model-specification","title":"Model specification","text":"<ul> <li>Two decision thresholds: <code>threshold_speed</code> and <code>threshold_accuracy</code></li> <li>One non-decision time: <code>ndt</code></li> <li>One drift direction: parameterized by a drift angle <code>drift_angle</code></li> <li>Three drift magnitudes: one per jitter level (15, 30, 45)</li> </ul> <pre><code>def negative_log_likelihood(params, rt, theta, isSpeed, jitter, model):\n    threshold_speed = params[0]\n    threshold_accuracy = params[1]\n    ndt = params[2]\n    drift_angle = params[3]\n\n    # Drift direction is shared across conditions\n    drift_direction = np.array([np.cos(drift_angle), np.sin(drift_angle)])\n\n    # Drift magnitude depends on jitter\n    drift_magnitudes = np.empty(rt.shape)\n    drift_magnitudes[jitter == 15] = params[4]\n    drift_magnitudes[jitter == 30] = params[5]\n    drift_magnitudes[jitter == 45] = params[6]\n\n    # Trial-wise drift vectors\n    drift_vectors = np.outer(drift_magnitudes, drift_direction)\n\n    # Condition-specific thresholds (speed vs accuracy)\n    logpdf_speed = model.joint_lpdf(\n        rt[isSpeed == 1],\n        theta[isSpeed == 1],\n        drift_vectors[isSpeed == 1, :],\n        ndt,\n        threshold_speed,\n    )\n\n    logpdf_accuracy = model.joint_lpdf(\n        rt[isSpeed == 0],\n        theta[isSpeed == 0],\n        drift_vectors[isSpeed == 0, :],\n        ndt,\n        threshold_accuracy,\n    )\n\n    return -np.sum(logpdf_speed) - np.sum(logpdf_accuracy)\n</code></pre>"},{"location":"tutorials/design_spesification/#4-set-parameter-bounds-and-fit-the-model-per-participant","title":"4. Set parameter bounds and fit the model per participant","text":"<pre><code>param_names = ['threshold_speed', \n               'threshold_accuracy',\n               'ndt', \n               'drift_angle',\n               'drift_magnitude15',\n               'drift_magnitude30',\n               'drift_magnitude45']\n\n\n# Parameter bounds\nbounds = [\n    (0.05, 5.0),   # threshold speed\n    (0.05, 5.0),   # threshold accuracy\n    (0.0, 1.0),    # non-decision time\n    (-np.pi, np.pi),    # drift angle\n    (0, 8.0),   # drift magnidute (length) for jitter=15\n    (0, 8.0),   # drift magnidute (length) for jitter=30\n    (0, 8.0),   # drift magnidute (length) for jitter=45\n]\n</code></pre> <pre><code>model = CDM(threshold_dynamic=\"fixed\")\n\nestimation_rows = []\n</code></pre> <pre><code># Estimate model parameters separately for each participant\nfor sbj in tqdm(data.Participant.unique()):\n    sbj_data = data[data['Participant']==sbj].reset_index(drop=True)\n\n    # Optimize the negative log-likelihood function\n    result = differential_evolution(\n                negative_log_likelihood,\n                bounds=bounds,\n                args=(sbj_data[\"rt\"].values, \n                      sbj_data[\"deviation\"].values,\n                      sbj_data[\"isSpeed\"].values,\n                      sbj_data[\"jitter\"].values, model),\n    )\n\n    k = len(result.x) # number of free parameters\n    n = sbj_data.shape[0] # number of trials for the participant\n    nlpdf = result.fun # optimized negative log-likelihood value\n\n    # store the goodness of fit criterion and estimated parameters for each subject\n    row = {\n        \"Participant\": sbj, \n        \"nlpdf\": nlpdf, \n        \"AIC\": 2 * nlpdf + 2 * k, \n        \"BIC\": 2 * nlpdf + k * np.log(n)\n    }\n    row.update(dict(zip(param_names, result.x)))\n\n    estimation_rows.append(row)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 12/12 [00:12&lt;00:00,  1.06s/it]\n</code></pre> <pre><code>estimation_data = pd.DataFrame(estimation_rows)\nestimation_data\n</code></pre> Participant nlpdf AIC BIC threshold_speed threshold_accuracy ndt drift_angle drift_magnitude15 drift_magnitude30 drift_magnitude45 100 335.535 685.07 715.837 0.866757 1.50936 0.440777 -0.0157439 3.59821 2.76672 1.54547 101 283.352 580.704 609.877 1.0362 1.33893 0.416766 -0.0199686 3.94078 2.66761 1.40861 110 557.592 1129.18 1158.34 0.978971 1.27506 0.337027 0.0578871 2.92682 1.52246 0.730462 120 471.097 956.194 985.189 0.905203 1.53838 0.362234 0.0143186 2.69224 1.7259 1.05211 130 248.978 511.956 541.172 0.715614 0.889673 0.2799 0.0284188 3.0901 2.15851 1.09002 140 93.2438 200.488 229.704 0.999547 1.04782 0.388389 0.00383741 4.87936 3.23159 1.58084 150 196.158 406.315 435.532 0.917433 0.870011 0.332569 0.0459289 3.89978 2.50724 1.43862 170 282.323 578.647 607.805 0.835069 1.09277 0.254983 0.0846156 3.43038 2.25192 1.16668 180 462.984 939.967 969.11 0.971128 1.69997 0.258889 -0.127637 2.87725 2.02574 1.12141 190 277.391 568.781 597.639 0.840641 1.94945 0.316306 -0.0698122 3.43441 2.26668 1.34496 200 427.305 868.61 897.619 0.883803 1.09596 0.232506 0.0471421 2.91083 2.05821 1.05827 210 303.888 621.777 650.876 0.894596 1.1362 0.368374 -0.0905744 3.27711 2.2957 1.26796"},{"location":"tutorials/design_spesification/#5-model-based-prediction-posterior-predictive-simulation","title":"5. Model-based prediction (posterior predictive simulation)","text":"<p>We next perform posterior predictive simulations using the fitted parameters. By comparing summary statistics from the observed data and model-generated data, we assess whether the model captures systematic effects of task instructions and stimulus difficulty.</p> <pre><code>n_sample_condition = 200\npredictions = []\n\nfor sbj in tqdm(data.Participant.unique()):\n    # model's parameters for each subject\n    prms = estimation_data[estimation_data[\"Participant\"] == sbj].iloc[0]\n\n    drift_dir = np.array([np.cos(prms[\"drift_angle\"]), \n                          np.sin(prms[\"drift_angle\"])])\n\n    for jitter in [15, 30, 45]:\n        drift_mag = prms[f\"drift_magnitude{jitter}\"]\n        drift_vec = drift_mag * drift_dir\n\n        # Speed condition\n        speed_df = model.simulate(\n            drift_vec,\n            prms[\"ndt\"],\n            threshold=prms[\"threshold_speed\"],\n            n_sample=n_sample_condition,\n        )\n        speed_df[\"isSpeed\"] = 1\n        speed_df[\"jitter\"] = jitter\n        speed_df[\"Participant\"] = sbj\n\n        # Accuracy condition\n        acc_df = model.simulate(\n            drift_vec,\n            prms[\"ndt\"],\n            threshold=prms[\"threshold_accuracy\"],\n            n_sample=n_sample_condition,\n        )\n        acc_df[\"isSpeed\"] = 0\n        acc_df[\"jitter\"] = jitter\n        acc_df[\"Participant\"] = sbj\n\n        predictions.append(pd.concat([speed_df, acc_df], ignore_index=True))\n\nmodel_prediction = pd.concat(predictions, ignore_index=True)\nmodel_prediction.head()\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 12/12 [00:02&lt;00:00,  4.92it/s]\n</code></pre> rt response isSpeed jitter Participant 0.662777 0.270706 1 15 100 0.578777 -0.612121 1 15 100 0.568777 0.182161 1 15 100 0.661777 -0.752912 1 15 100 0.714777 -0.727197 1 15 100"},{"location":"tutorials/design_spesification/#6-compare-summary-measures","title":"6. Compare summary measures","text":"<p>A common approach is to compare mean RT and mean absolute deviation across conditions:</p> <pre><code>data_plot = data.copy()\ndata_plot[\"abs_dev\"] = np.abs(data_plot[\"deviation\"])\n\npred_plot = model_prediction.copy()\npred_plot[\"abs_dev\"] = np.abs(pred_plot[\"response\"])\n</code></pre> <pre><code># Helper: compute mean + SEM\ndef summarize(df, value_col, source_name):\n    g = (\n        df.groupby([\"jitter\", \"isSpeed\"])[value_col]\n        .agg(mean=\"mean\", sem=\"sem\")\n        .reset_index()\n    )\n    g[\"source\"] = source_name\n    g[\"metric\"] = value_col\n    return g\n</code></pre> <pre><code>def plot_metric(ax, metric, ylabel):\n    sub = summary[summary[\"metric\"] == metric].copy()\n\n    # plot each (source \u00d7 condition) as a separate line with error bars\n    for (source, condition), sdf in sub.groupby([\"source\", \"condition\"]):\n        sdf = sdf.sort_values(\"jitter\")\n        ax.errorbar(\n            sdf[\"jitter\"],\n            sdf[\"mean\"],\n            yerr=sdf[\"sem\"],\n            marker=\"o\",\n            linewidth=2,\n            linestyle=\"-\" if source == \"Data\" else \"--\",\n            label=f\"{source} ({condition})\",\n            capsize=3,\n        )\n\n    ax.set_xlabel(\"Difficulty (jitter, degrees)\")\n    ax.set_ylabel(ylabel)\n    ax.legend(frameon=False)\n</code></pre> <pre><code>summary = pd.concat(\n    [\n        summarize(data_plot, \"rt\", \"Data\"),\n        summarize(data_plot, \"abs_dev\", \"Data\"),\n        summarize(pred_plot, \"rt\", \"Prediction\"),\n        summarize(pred_plot, \"abs_dev\", \"Prediction\"),\n    ],\n    ignore_index=True,\n)\n\nsummary[\"condition\"] = summary[\"isSpeed\"].map({0: \"Accuracy\", 1: \"Speed\"})\nsummary[\"jitter\"] = summary[\"jitter\"].astype(int)\n</code></pre> <p>We focus on two key summary measures: mean response time, which indexes response speed, and mean absolute response deviation, which quantifies response precision. Together, these measures capture the speed\u2013accuracy trade-off and characterize how task difficulty influences both response speed and response precision in continuous-report tasks.</p> <pre><code>fig, axes = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True)\n\nplot_metric(axes[0], \"rt\", \"Mean RT (s)\")\nplot_metric(axes[1], \"abs_dev\", \"Mean |deviation| (radians)\")\n\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/design_spesification/#notes","title":"Notes","text":"<ul> <li>This pattern\u2014mapping design factors to different model parameters\u2014scales to more complex designs   (e.g., stimulus-specific drifts, participant-level covariates, hierarchical extensions).</li> <li>The key idea is to construct trial-wise parameters (like <code>drift_vectors</code>) and to route trials   to condition-specific parameters (like thresholds) inside the likelihood.</li> </ul>"},{"location":"tutorials/design_spesification/#references","title":"References","text":"<p>Kvam, P. D. (2019). Modeling accuracy, response time, and bias in continuous orientation judgments. Journal of Experimental Psychology: Human Perception and Performance, 45(3), 301\u2013318. https://doi.org/10.1037/xhp0000606</p>"},{"location":"tutorials/mixture_models/","title":"Mixture Process Models for Continuous-response Tasks","text":"<p>Mixture process models are an important class of cognitive models for continuous-response tasks, and they have been widely used in the visual working memory literature. These models assume that observed responses arise from a mixture of distinct cognitive processes, such as memory-based responding and random guessing.</p> <p>This tutorial demonstrates how to fit mixture models within the CRDDM framework. Specifically, we implement a two-component mixture model for continuous-report visual working memory tasks, inspired by the seminal work of Zhang and Luck (2008).</p> <p>In a typical visual working memory task, participants are asked to memorize the features (e.g., colors) of a set of stimuli. After a brief retention period, they are cued to report the remembered feature of one item by responding on a continuous response scale as below:</p> <p></p> <p>In this tutorial, we analyze data from Experiment 4 of Fennel and Ratcliff (2023). The dataset contains behavioral data from six participants performing a visual working memory task with a circular response scale. On each trial, participants were required to memorize either two or four items (i.e., <code>setSize</code> \\(\\in \\{2, 4\\}\\)), allowing us to examine how memory load influences both response precision and guessing behavior.</p>"},{"location":"tutorials/mixture_models/#1-import-required-packages","title":"1. Import required packages","text":"<pre><code>import numpy as np\nimport seaborn as sns\nfrom tqdm import tqdm\n\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\nfrom scipy.optimize import differential_evolution\n\nfrom CRDDM.utility.datasets import load_fennell2023\nfrom CRDDM.Models.Circular import CircularDiffusionModel as CDM\n</code></pre>"},{"location":"tutorials/mixture_models/#2-load-the-dataset","title":"2. Load the dataset","text":"<pre><code>data = load_fennell2023()\n\ndata.head()\n</code></pre> subjectNumber blockNumber trialNumber setSize rt responseError 0 1 1 1 4 0.613 -2.44346 1 1 1 2 4 0.723 -0.471239 2 1 1 3 4 0.903 1.39626 3 1 1 4 2 0.734 -0.15708 4 1 1 5 2 0.757 -0.558505 <p>This dataset includes:</p> <ul> <li><code>subjectNumber</code>: participant identifier,</li> <li><code>blockNumber</code>: block index,</li> <li><code>trialNumber</code>: trial index,</li> <li><code>setSize</code>: number of items to memorize,</li> <li><code>rt</code>: response time (seconds),</li> <li><code>responseError</code>: angular response error (radians).</li> </ul>"},{"location":"tutorials/mixture_models/#3-define-a-two-component-mixture-likelihood","title":"3. Define a two-component mixture likelihood","text":"<p>Discrete theories of visual working memory (e.g., Zhang and Luck, 2008) propose that working memory consists of a limited number of discrete \u201cslots.\u201d Under this view, an item is either successfully stored in working memory or not, and responses reflect a mixture of memory-based reports and random guesses.</p> <p>Zhang and Luck (2008) formalized this idea in a hybrid discrete model, in which the precision of memory representations decreases with increasing set size up to the capacity limit. In the diffusion modeling framework, this reduction in precision can be captured by allowing the drift magnitude of the diffusion process to vary across set sizes. Once the capacity limit is exceeded, additional items are assumed not to be stored in working memory; responses to these items are therefore attributed to guessing, while the precision of stored items remains constant.</p> <p></p> <p>Within our mixture modeling approach, this theory motivates a process in which guessing occurs primarily when the number of presented stimuli exceeds working memory capacity (typically assumed to be around three items). Accordingly, for trials with <code>setSize=2</code>, the probability of guessing is fixed to zero.</p> <p>In the context of our mixture modeling approach, this theory motivates a process in which guessing occurs primarily when the number of presented stimuli exceeds working memory capacity (typically assumed to be around three items). Consequently, the probability of guessing is set to zero to .</p> <p>The model therefore assumes that, on each trial with <code>setSize=4</code>:</p> <ul> <li>with probability <code>1 \u2212 p_guess</code>, responses are generated by a circular diffusion process reflecting memory-based responding;</li> <li>with probability <code>p_guess</code>, responses are generated by a zero-drift process represeing the guessing process.</li> </ul> <p>and on each trial with <code>setSize=2</code>:</p> <ul> <li>Responses are generated by a circular diffusion process reflecting memory-based responding and there is no guessing component.</li> </ul> <p>Both the drift magnitude of the diffusion component and the guessing probability are allowed to depend on memory set size, enabling the model to capture systematic effects of memory load on both response precision and guessing behavior.</p> <pre><code>def negative_log_likelihood(params, rt, theta, setSize, model):\n    threshold =  params[0] \n    ndt = params[1]\n    drift_angle = params[2]\n\n    drift_direction = np.array([np.cos(drift_angle), \n                                np.sin(drift_angle)])\n\n    # Drift magnitudes by set size\n    drift_magnitudes = np.empty(setSize.shape)\n    drift_magnitudes[setSize == 2] = params[3]\n    drift_magnitudes[setSize == 4] = params[4]\n\n    # Trial-wise drift vectors\n    drift_vectors = np.outer(drift_magnitudes, drift_direction)\n\n    # Weights of geussing process by set size\n    p_guess = np.empty(setSize.shape)\n    p_guess[setSize==2] = 0 \n    p_guess[setSize==4] = params[5]    \n\n    non_guesing_pdf = np.exp(model.joint_lpdf(rt, theta, drift_vectors, ndt, threshold))\n    gussing_pdf = np.exp(model.joint_lpdf(rt, theta, np.zeros((2,)), ndt, threshold))\n\n    mixture_pdf = (1 - p_guess) * non_guesing_pdf + p_guess * gussing_pdf\n    logpdf = np.log(mixture_pdf)\n\n    return -np.sum(logpdf)\n</code></pre>"},{"location":"tutorials/mixture_models/#4-estimate-parameters-for-each-participant","title":"4. Estimate parameters for each participant","text":"<pre><code>param_names = ['threshold', \n               'ndt', \n               'drift_angle',\n               'drift_magnitude2',\n               'drift_magnitude4',\n               'p_guess',\n              ]\n\n\n# Parameter bounds\nbounds = [\n    (0.05, 5.0),   # threshold\n    (0.0, 1.0),    # non-decision time\n    (-np.pi, np.pi),    # drift angle\n    (0, 8.0),   # drift magnidute (length) for setSize=2\n    (0, 8.0),   # drift magnidute (length) for setSize=4\n    (0.0, 1.0), # p_guess for setSize=4\n]\n</code></pre> <pre><code>model = CDM(threshold_dynamic='fixed')\nestimation_rows = []\n\n# Estimate model parameters separately for each participant\nfor sbj in tqdm(data.subjectNumber.unique()):\n    sbj_data = data[data['subjectNumber']==sbj].reset_index(drop=True)\n\n    # Optimize the negative log-likelihood function\n    result = differential_evolution(\n                negative_log_likelihood,\n                bounds=bounds,\n                args=(sbj_data[\"rt\"].values, \n                      sbj_data[\"responseError\"].values, \n                      sbj_data[\"setSize\"].values, model),\n    )\n\n    k = len(result.x) # number of free parameters\n    n = sbj_data.shape[0] # number of trials for the participant\n    nlpdf = result.fun # optimized negative log-likelihood value\n\n    # store the goodness of fit criterion and estimated parameters for each subject\n    row = {\n        \"subjectNumber\": sbj, \n        \"nlpdf\": nlpdf, \n        \"AIC\": 2 * nlpdf + 2 * k, \n        \"BIC\": 2 * nlpdf + k * np.log(n)\n    }\n    row.update(dict(zip(param_names, result.x)))\n\n    estimation_rows.append(row)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 6/6 [00:50&lt;00:00,  8.42s/it]\n</code></pre> <pre><code>estimation_data = pd.DataFrame(estimation_rows)\nestimation_data\n</code></pre> subjectNumber nlpdf AIC BIC threshold ndt drift_angle drift_magnitude2 drift_magnitude4 p_guess 0 1 2480.56 4973.12 5008.68 1.34114 0.281544 0.020743 2.77962 2.36926 0.293553 1 2 3677.45 7366.91 7403.92 1.42642 0.37766 0.0682357 2.63049 2.40342 0.309109 2 3 1539.65 3091.29 3128.73 1.87989 0.174312 -0.00958925 3.66752 3.06354 0.0912635 3 4 4319.23 8650.46 8687.52 1.73828 0.412406 0.00403091 2.53822 2.19175 0.290414 4 5 3961.68 7935.35 7972.76 1.37763 0.128847 0.020625 2.44562 2.20333 0.287797 5 6 4376.61 8765.21 8802.6 1.57959 0.167219 0.0106277 2.34714 2.17065 0.229419"},{"location":"tutorials/mixture_models/#5-model-based-prediction-posterior-predictive-simulation","title":"5. Model-based prediction (posterior predictive simulation)","text":"<p>We next perform posterior predictive simulations using the fitted parameters. By comparing summary statistics from the observed data and model-generated data, we assess whether the model captures systematic effects of task instructions and stimulus difficulty.</p> <pre><code>n_sample = 500\nsimulated = []\n\nfor sbj in data.subjectNumber.unique():\n    prms = estimation_data[estimation_data.subjectNumber == sbj].iloc[0]\n\n    drift_dir = np.array([\n        np.cos(prms[\"drift_angle\"]),\n        np.sin(prms[\"drift_angle\"]),\n    ])\n\n    for setSize in [2, 4]:\n        drift_vec = prms[f\"drift_magnitude{setSize}\"] * drift_dir\n\n        if setSize == 2:\n            p_guess = 0\n        else:\n            p_guess = prms[\"p_guess\"]\n\n        non_guess = model.simulate(\n            drift_vec,\n            prms[\"ndt\"],\n            threshold=prms[\"threshold\"],\n            n_sample=n_sample - int(p_guess * n_sample),\n        )\n\n        guess = model.simulate(\n            np.zeros((2,)),\n            prms[\"ndt\"],\n            threshold=prms[\"threshold\"],\n            n_sample=int(p_guess * n_sample),\n        )\n\n        df = pd.concat([non_guess, guess])\n        df[\"setSize\"] = setSize\n        df[\"subjectNumber\"] = sbj\n\n        simulated.append(df)\n\nmodel_prediction = pd.concat(simulated, ignore_index=True)\nmodel_prediction.head()\n</code></pre> rt response setSize subjectNumber 0 1.35754 -0.157263 2 1 1 0.658544 0.616766 2 1 2 0.625544 0.0389916 2 1 3 0.530544 0.396273 2 1 4 0.678544 -0.785103 2 1"},{"location":"tutorials/mixture_models/#6-compare-summary-measures","title":"6. Compare summary measures","text":"<p>A common approach is to compare mean RT and mean absolute deviation across set size:</p> <pre><code>data_plot = data.copy()\ndata_plot[\"abs_dev\"] = np.abs(data['responseError'])\n\npred_plot = model_prediction.copy()\npred_plot[\"abs_dev\"] = np.abs(pred_plot['response'])\n</code></pre> <pre><code># Helper: compute mean + SEM\ndef summarize(df, value_col, source_name):\n    g = (\n        df.groupby([\"setSize\"])[value_col]\n        .agg(mean=\"mean\", sem=\"sem\")\n        .reset_index()\n    )\n    g[\"source\"] = source_name\n    g[\"metric\"] = value_col\n    return g\n</code></pre> <pre><code>def plot_metric(ax, metric, ylabel):\n    sub = summary[summary[\"metric\"] == metric].copy()\n\n    # plot each source as a separate line with error bars\n    for (source, ), sdf in sub.groupby([\"source\"]):\n        sdf = sdf.sort_values(\"setSize\")\n        ax.errorbar(\n            sdf[\"setSize\"],\n            sdf[\"mean\"],\n            yerr=sdf[\"sem\"],\n            marker=\"o\",\n            linewidth=2,\n            linestyle=\"-\" if source == \"Data\" else \"--\",\n            label=f\"{source}\",\n            capsize=3,\n        )\n\n    ax.set_xlabel(\"Set size\")\n    ax.set_ylabel(ylabel)\n    ax.legend(frameon=False)\n    ax.set_xticks([2, 4], [2, 4])\n</code></pre> <pre><code>summary = pd.concat(\n    [\n        summarize(data_plot.groupby(['subjectNumber', 'setSize']).mean(), \n                  \"rt\", \"Data\"),\n        summarize(data_plot.groupby(['subjectNumber', 'setSize']).mean(), \"abs_dev\", \"Data\"),\n        summarize(pred_plot.groupby(['subjectNumber', 'setSize']).mean(), \"rt\", \"Prediction\"),\n        summarize(pred_plot.groupby(['subjectNumber', 'setSize']).mean(), \"abs_dev\", \"Prediction\"),\n    ],\n    ignore_index=True,\n)\n\nsummary[\"setSize\"] = summary[\"setSize\"].astype(int)\n</code></pre> <pre><code>fig, axes = plt.subplots(1, 2, figsize=(10, 4), constrained_layout=True)\n\nplot_metric(axes[0], \"rt\", \"Mean RT (s)\")\nplot_metric(axes[1], \"abs_dev\", \"Mean |deviation| (radians)\")\n\nplt.show()\n</code></pre> <p></p>"},{"location":"tutorials/mixture_models/#notes","title":"Notes","text":"<ul> <li> <p>Mixture models can also be used to account for multimodal response-error distributions, as observed in continuous-report tasks (e.g., Bays et al, 2009).</p> </li> <li> <p>CRDDM supports straightforward implementation of mixture models with more than two components, and this framework generalizes naturally to richer mixture structures and alternative cognitive process assumptions.</p> </li> </ul>"},{"location":"tutorials/mixture_models/#references","title":"References","text":"<ul> <li> <p>Bays, P. M., Catalao, R. F., &amp; Husain, M. (2009). The precision of visual working memory is set by allocation of a shared resource. Journal of Vision, 9(10), 7-7. https://doi.org/10.1167/9.10.7</p> </li> <li> <p>Fennell, A., &amp; Ratcliff, R. (2023). A spatially continuous diffusion model of visual working memory. Cognitive Psychology, 145, 101595. https://doi.org/10.1016/j.cogpsych.2023.101595</p> </li> <li> <p>Zhang, W., &amp; Luck, S. J. (2008). Discrete fixed-resolution representations in visual working memory. Nature, 453(7192), 233-235. https://doi.org/10.1038/nature06860</p> </li> </ul>"},{"location":"tutorials/quickstart/","title":"Quick Start: Circular Diffusion Model","text":"<p>This tutorial demonstrates how to simulate data from a Circular Diffusion Model (CDM) and recover model parameters using likelihood-based estimation with CRDDM.</p>"},{"location":"tutorials/quickstart/#1-import-required-packages","title":"1. Import required packages","text":"<pre><code>import numpy as np\n\nfrom scipy.optimize import differential_evolution\nfrom CRDDM.Models.Circular import CircularDiffusionModel\n</code></pre>"},{"location":"tutorials/quickstart/#2-create-a-circular-diffusion-model","title":"2. Create a circular diffusion model","text":"<pre><code>model = CircularDiffusionModel(threshold_dynamic=\"fixed\")\n</code></pre>"},{"location":"tutorials/quickstart/#3-simulate-continuous-response-decision-data","title":"3. Simulate continuous-response decision data","text":"<pre><code># Ground-truth parameters\nthreshold = 1.0\ndrift_vector = np.array([1.0, 0.0])  # drift in x and y directions\nndt = 0.25                           # non-decision time\n\n# Simulate data\nsim_data = model.simulate(\n    drift_vector=drift_vector,\n    ndt=ndt,\n    threshold=threshold,\n    n_sample=1000\n)\n\nsim_data.head()\n</code></pre> <p>The simulated dataset contains: - <code>rt</code>: response times - <code>response</code>: continuous angular responses on the circle in radian</p>"},{"location":"tutorials/quickstart/#4-define-the-likelihood-function","title":"4. Define the likelihood function","text":"<p>We estimate parameters by maximizing the joint likelihood of response times and continuous responses.</p> <pre><code>def negative_log_likelihood(params, rt, theta, model):\n    threshold = params[0]\n    ndt = params[1]\n    drift_vec = np.array([params[2], params[3]])\n\n    logpdf = model.joint_lpdf(rt, theta, drift_vec, ndt, threshold)\n    return -np.sum(logpdf)\n</code></pre>"},{"location":"tutorials/quickstart/#5-estimate-parameters-using-differential-evolution","title":"5. Estimate parameters using differential evolution","text":"<pre><code># Parameter bounds\nbounds = [\n    (0.05, 5.0),   # threshold\n    (0.0, 2.0),    # non-decision time\n    (-5.0, 5.0),   # drift_x\n    (-5.0, 5.0),   # drift_y\n]\n\nparam_names = [\"threshold\", \"ndt\", \"drift_x\", \"drift_y\"]\n\nresult = differential_evolution(\n    negative_log_likelihood,\n    bounds=bounds,\n    args=(sim_data[\"rt\"].values, sim_data[\"response\"].values, model),\n)\n</code></pre>"},{"location":"tutorials/quickstart/#6-inspect-recovered-parameters","title":"6. Inspect recovered parameters","text":"<pre><code>for name, value in zip(param_names, result.x):\n    print(f\"{name}: {value:.3f}\")\n</code></pre> <p>The recovered parameters should be close to the values used for simulation, demonstrating correct likelihood evaluation and parameter recovery.</p>"},{"location":"tutorials/quickstart/#notes","title":"Notes","text":"<ul> <li>This example uses a fixed decision threshold.</li> <li>Other threshold dynamics and response spaces (e.g., spherical or hyperspherical models) follow the same workflow.</li> </ul>"}]}